diff --git a/iokit/DriverKit/IOKernelReportStructs.h b/iokit/DriverKit/IOKernelReportStructs.h
new file mode 100644
index 00000000..71c98a84
--- /dev/null
+++ b/iokit/DriverKit/IOKernelReportStructs.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2012-2014 Apple Computer, Inc.  All Rights Reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+// Internal data structures to be used by IOReporters and User Space Observers
+
+
+#ifndef _IOKERNELREPORTSTRUCTS_H_
+#define _IOKERNELREPORTSTRUCTS_H_
+
+#include <stdint.h>
+
+#if KERNEL
+#include <IOKit/IOReportTypes.h>
+#else
+#include <DriverKit/IOReportTypes.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// Drivers participating in IOReporting can advertise channels by
+// publishing properties in the I/O Kit registry.  Various helper
+// mechanisms exist to produce correctly-formatted legends.
+// 12836893 tracks advertising channels in user space.
+#define kIOReportLegendPublicKey        "IOReportLegendPublic"      // bool
+#define kIOReportLegendKey              "IOReportLegend"            // arr
+#define kIOReportLegendChannelsKey      "IOReportChannels"          // arr
+#define kIOReportLegendGroupNameKey     "IOReportGroupName"         // str
+#define kIOReportLegendSubGroupNameKey  "IOReportSubGroupName"      // str
+#define kIOReportLegendInfoKey          "IOReportChannelInfo"       // dict
+#define kIOReportLegendUnitKey          "IOReportChannelUnit"       // num
+#define kIOReportLegendConfigKey        "IOReportChannelConfig"     // data
+#define kIOReportLegendStateNamesKey    "IOReportChannelStateNames" // str[]
+
+// in an I/O Kit registry legend, a small "array struct" represents a channel
+#define kIOReportChannelIDIdx           0       // required
+#define kIOReportChannelTypeIdx         1       // required
+#define kIOReportChannelNameIdx         2       // optional
+
+/*  Histogram Segment Configuration
+ *   Currently supports 2 types of scaling to compute bucket upper bounds,
+ *   linear or exponential.
+ *   scale_flag = 0 -> linear scale
+ *                1 -> exponential scale
+ *   upper_bound[n] = (scale_flag) ? pow(base,(n+1)) : base * (n+1);
+ */
+#define kIOHistogramScaleLinear 0
+#define kIOHistogramScaleExponential 1
+typedef struct {
+	uint32_t    base_bucket_width;// segment[0].bucket[0] = [0, base_width]
+	uint32_t    scale_flag;       // bit 0 only in current use (see #defs)
+	uint32_t    segment_idx;      // for multiple segments histograms
+	uint32_t    segment_bucket_count;// number of buckets in this segment
+} __attribute((packed)) IOHistogramSegmentConfig;
+
+// "normalized distribution"(FIXME?) internal format (unused?)
+typedef struct {
+	uint64_t    samples;
+	uint64_t    mean;
+	uint64_t    variance;
+	uint64_t    reserved;
+} __attribute((packed)) IONormDistReportValues;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _IOKERNELREPORTSTRUCTS_H_
diff --git a/iokit/DriverKit/IOKitKeys.h b/iokit/DriverKit/IOKitKeys.h
new file mode 100644
index 00000000..f4c43e83
--- /dev/null
+++ b/iokit/DriverKit/IOKitKeys.h
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+/*
+ * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved.
+ *
+ * Common symbol definitions for IOKit.
+ *
+ * HISTORY
+ *
+ */
+
+
+#ifndef _IOKIT_IOKITKEYS_H
+#define _IOKIT_IOKITKEYS_H
+
+// properties found in the registry root
+#define kIOKitBuildVersionKey           "IOKitBuildVersion"
+#define kIOKitDiagnosticsKey            "IOKitDiagnostics"
+// a dictionary keyed by plane name
+#define kIORegistryPlanesKey            "IORegistryPlanes"
+#define kIOCatalogueKey                 "IOCatalogue"
+
+// registry plane names
+#define kIOServicePlane                 "IOService"
+#define kIOPowerPlane                   "IOPower"
+#define kIODeviceTreePlane              "IODeviceTree"
+#define kIOAudioPlane                   "IOAudio"
+#define kIOFireWirePlane                "IOFireWire"
+#define kIOUSBPlane                     "IOUSB"
+
+// registry ID number
+#define kIORegistryEntryIDKey           "IORegistryEntryID"
+// property name to get array of property names
+#define kIORegistryEntryPropertyKeysKey "IORegistryEntryPropertyKeys"
+// property name to allow only the given keys present in an OSDictionary from
+// a user space call to IORegistryEntry::setProperties (OSArray)
+#define kIORegistryEntryAllowableSetPropertiesKey               "IORegistryEntryAllowableSetProperties"
+// property name to single thread a user space call to IORegistryEntry::setProperties (OSBoolean)
+#define kIORegistryEntryDefaultLockingSetPropertiesKey  "IORegistryEntryDefaultLockingSetProperties"
+
+
+// IOService class name
+#define kIOServiceClass                 "IOService"
+
+// IOResources class name
+#define kIOResourcesClass               "IOResources"
+
+// IOService driver probing property names
+#define kIOClassKey                     "IOClass"
+#define kIOProbeScoreKey                "IOProbeScore"
+#define kIOKitDebugKey                  "IOKitDebug"
+
+// DriverKit class keys
+#define kIOUserClassKey                 "IOUserClass"
+#define kIOUserClassesKey               "IOUserClasses"
+
+// Properties to be supported as API
+#define kIOSupportedPropertiesKey       "IOSupportedProperties"
+// Properties writable by dexts
+#define kIOUserServicePropertiesKey     "IOUserServiceProperties"
+
+
+// IOService matching property names
+#define kIOProviderClassKey             "IOProviderClass"
+#define kIONameMatchKey                 "IONameMatch"
+#define kIOPropertyMatchKey             "IOPropertyMatch"
+#define kIOPropertyExistsMatchKey       "IOPropertyExistsMatch"
+#define kIOPathMatchKey                 "IOPathMatch"
+#define kIOLocationMatchKey             "IOLocationMatch"
+#define kIOParentMatchKey               "IOParentMatch"
+#define kIOResourceMatchKey             "IOResourceMatch"
+#define kIOResourceMatchedKey           "IOResourceMatched"
+#define kIOMatchedServiceCountKey       "IOMatchedServiceCountMatch"
+
+#define kIONameMatchedKey               "IONameMatched"
+
+#define kIOMatchCategoryKey             "IOMatchCategory"
+#define kIODefaultMatchCategoryKey      "IODefaultMatchCategory"
+
+#define kIOMatchedPersonalityKey        "IOMatchedPersonality"
+#define kIORematchPersonalityKey        "IORematchPersonality"
+#define kIORematchCountKey              "IORematchCount"
+#define kIODEXTMatchCountKey            "IODEXTMatchCount"
+
+// Property specifying the entitlement to check against an IOUserClient's opening process
+// kOSBooleanFalse - Allow access (no entitlements required)
+// string - If the opening process has the named entitlement with value == boolean true, allow access
+#define kIOUserClientEntitlementsKey   "IOUserClientEntitlements"
+
+// Entitlements to check against dext process
+// Property is an array, one or more of which may match, of:
+//   an array of entitlement strings, all must be present
+// Any array can be a single string.
+#define kIOServiceDEXTEntitlementsKey   "IOServiceDEXTEntitlements"
+
+// Entitlement required to open dext connection
+#define kIODriverKitEntitlementKey      "com.apple.developer.driverkit"
+
+// Entitlements required to open dext IOUserClient
+// Property is an array of strings containing CFBundleIdentifiers of service being opened
+#define kIODriverKitUserClientEntitlementsKey "com.apple.developer.driverkit.userclient-access"
+
+// Allows the entitled process to open a user client connection to any dext that has specific entitlements
+// Property is an array of strings containing entitlements, one of which needs to be present
+// in the dext providing the user client being opened
+#define kIODriverKitRequiredEntitlementsKey "com.apple.private.driverkit.driver-access"
+
+// Specifies that this driver is used for internal tests. This opts the driver out of our policy to
+// reboot the device if a driver crashes too often.
+#define kIODriverKitTestDriverEntitlementKey "com.apple.private.driverkit.test-driver"
+
+// Entitlement of a dext that allows any task to open one of its IOUserClients
+#define kIODriverKitUserClientEntitlementAllowAnyKey "com.apple.developer.driverkit.allow-any-userclient-access"
+
+#define kIODriverKitUserClientEntitlementAdministratorKey "com.apple.developer.driverkit.administrator"
+
+// Entitlements for third party drivers on iOS
+#define kIODriverKitUserClientEntitlementCommunicatesWithDriversKey "com.apple.developer.driverkit.communicates-with-drivers"
+#define kIODriverKitUserClientEntitlementAllowThirdPartyUserClientsKey "com.apple.developer.driverkit.allow-third-party-userclients"
+
+// Other DriverKit entitlements
+#define kIODriverKitUSBTransportEntitlementKey "com.apple.developer.driverkit.transport.usb"
+#define kIODriverKitHIDTransportEntitlementKey "com.apple.developer.driverkit.transport.hid"
+#define kIODriverKitHIDFamilyDeviceEntitlementKey "com.apple.developer.driverkit.family.hid.device"
+#define kIODriverKitHIDFamilyEventServiceEntitlementKey "com.apple.developer.driverkit.family.hid.eventservice"
+#define kIODriverKitTransportBuiltinEntitlementKey "com.apple.developer.driverkit.builtin"
+
+// Entitlement required to read nvram root-only properties as non-root user
+#define kIONVRAMReadAccessKey           "com.apple.private.iokit.nvram-read-access"
+// Entitlement required to write nvram properties as non-root user
+#define kIONVRAMWriteAccessKey           "com.apple.private.iokit.nvram-write-access"
+// Entitlement required to set properties on the IOResources object as non-root user
+#define kIOResourcesSetPropertyKey       "com.apple.private.iokit.ioresources.setproperty"
+// Entitlement required to read/write to the system nvram region
+#define kIONVRAMSystemAllowKey           "com.apple.private.iokit.system-nvram-allow"
+
+// When possible, defer matching of this driver until kextd has started.
+#define kIOMatchDeferKey                                "IOMatchDefer"
+
+// Published after processor_start() has been called on all CPUs at boot time.
+#define kIOAllCPUInitializedKey                         "IOAllCPUInitialized"
+
+// IOService default user client class, for loadable user clients
+#define kIOUserClientClassKey           "IOUserClientClass"
+
+// key to find IOMappers
+#define kIOMapperIDKey                          "IOMapperID"
+
+#ifdef XNU_KERNEL_PRIVATE
+// Apple Kext Exclude List
+#define kIOExcludeListBundleID                  "com.apple.driver.KextExcludeList"
+#endif
+
+#define kIOUserClientCrossEndianKey             "IOUserClientCrossEndian"
+#define kIOUserClientCrossEndianCompatibleKey   "IOUserClientCrossEndianCompatible"
+#define kIOUserClientSharedInstanceKey          "IOUserClientSharedInstance"
+#if KERNEL_PRIVATE
+#define kIOUserClientMessageAppSuspendedKey     "IOUserClientMessageAppSuspended"
+#endif
+
+#define kIOUserClientDefaultLockingKey                                          "IOUserClientDefaultLocking"
+#define kIOUserClientDefaultLockingSetPropertiesKey                 "IOUserClientDefaultLockingSetProperties"
+#define kIOUserClientDefaultLockingSingleThreadExternalMethodKey    "IOUserClientDefaultLockingSingleThreadExternalMethod"
+
+// diagnostic string describing the creating task
+#define kIOUserClientCreatorKey         "IOUserClientCreator"
+// the expected cdhash value of the userspace driver executable
+#define kIOUserServerCDHashKey          "IOUserServerCDHash"
+
+#define kIOUserUserClientKey                    "IOUserUserClient"
+
+#define kIOUserServerOneProcessKey      "IOUserServerOneProcess"
+#define kIOUserServerPreserveUserspaceRebootKey "IOUserServerPreserveUserspaceReboot"
+
+
+// IOService notification types
+#define kIOPublishNotification          "IOServicePublish"
+#define kIOFirstPublishNotification     "IOServiceFirstPublish"
+#define kIOMatchedNotification          "IOServiceMatched"
+#define kIOFirstMatchNotification       "IOServiceFirstMatch"
+#define kIOTerminatedNotification       "IOServiceTerminate"
+#define kIOWillTerminateNotification    "IOServiceWillTerminate"
+
+// IOService interest notification types
+#define kIOGeneralInterest              "IOGeneralInterest"
+#define kIOBusyInterest                 "IOBusyInterest"
+#define kIOAppPowerStateInterest        "IOAppPowerStateInterest"
+#define kIOPriorityPowerStateInterest   "IOPriorityPowerStateInterest"
+
+#define kIOPlatformDeviceMessageKey     "IOPlatformDeviceMessage"
+
+// IOService interest notification types
+#define kIOCFPlugInTypesKey             "IOCFPlugInTypes"
+
+#define kIOCompatibilityMatchKey            "IOCompatibilityMatch"
+#define kIOCompatibilityPropertiesKey   "IOCompatibilityProperties"
+#define kIOPathKey                                      "IOPath"
+
+
+// properties found in services that implement command pooling
+#define kIOCommandPoolSizeKey           "IOCommandPoolSize"             // (OSNumber)
+
+// properties found in services that implement priority
+#define kIOMaximumPriorityCountKey      "IOMaximumPriorityCount"        // (OSNumber)
+
+// properties found in services that have transfer constraints
+#define kIOMaximumBlockCountReadKey             "IOMaximumBlockCountRead"             // (OSNumber)
+#define kIOMaximumBlockCountWriteKey            "IOMaximumBlockCountWrite"            // (OSNumber)
+#define kIOMaximumByteCountReadKey              "IOMaximumByteCountRead"              // (OSNumber)
+#define kIOMaximumByteCountWriteKey             "IOMaximumByteCountWrite"             // (OSNumber)
+#define kIOMaximumSegmentCountReadKey           "IOMaximumSegmentCountRead"           // (OSNumber)
+#define kIOMaximumSegmentCountWriteKey          "IOMaximumSegmentCountWrite"          // (OSNumber)
+#define kIOMaximumSegmentByteCountReadKey       "IOMaximumSegmentByteCountRead"       // (OSNumber)
+#define kIOMaximumSegmentByteCountWriteKey      "IOMaximumSegmentByteCountWrite"      // (OSNumber)
+#define kIOMinimumSegmentAlignmentByteCountKey  "IOMinimumSegmentAlignmentByteCount"  // (OSNumber)
+#define kIOMaximumSegmentAddressableBitCountKey "IOMaximumSegmentAddressableBitCount" // (OSNumber)
+#define kIOMinimumSaturationByteCountKey        "IOMinimumSaturationByteCount"        // (OSNumber)
+#define kIOMaximumSwapWriteKey                  "IOMaximumSwapWrite"                  // (OSNumber)
+
+// properties found in services that wish to describe an icon
+//
+// IOIcon =
+// {
+//     CFBundleIdentifier   = "com.example.driver.example";
+//     IOBundleResourceFile = "example.icns";
+// };
+//
+// where IOBundleResourceFile is the filename of the resource
+
+#define kIOIconKey               "IOIcon"               // (OSDictionary)
+#define kIOBundleResourceFileKey "IOBundleResourceFile" // (OSString)
+
+#define kIOBusBadgeKey           "IOBusBadge"           // (OSDictionary)
+#define kIODeviceIconKey         "IODeviceIcon"         // (OSDictionary)
+
+// property of root that describes the machine's serial number as a string
+#define kIOPlatformSerialNumberKey      "IOPlatformSerialNumber"        // (OSString)
+
+// property of root that describes the machine's UUID as a string
+#define kIOPlatformUUIDKey      "IOPlatformUUID"        // (OSString)
+
+// IODTNVRAM property keys
+#define kIONVRAMBootArgsKey             "boot-args"
+#define kIONVRAMDeletePropertyKey       "IONVRAM-DELETE-PROPERTY"
+#define kIONVRAMSyncNowPropertyKey      "IONVRAM-SYNCNOW-PROPERTY"
+#define kIONVRAMActivateCSRConfigPropertyKey    "IONVRAM-ARMCSR-PROPERTY"
+#define kIODTNVRAMPanicInfoKey          "aapl,panic-info"
+#define kIONVRAMDeletePropertyKeyWRet   "IONVRAM-DELETEWRET-PROPERTY"
+
+// keys for complex boot information
+#define kIOBootDeviceKey          "IOBootDevice"                // dict | array of dicts
+#define kIOBootDevicePathKey      "IOBootDevicePath"    // arch-neutral OSString
+#define kIOBootDeviceSizeKey      "IOBootDeviceSize"    // OSNumber of bytes
+
+// keys for OS Version information
+#define kOSBuildVersionKey              "OS Build Version"
+
+//
+#define kIOStateNotificationItemCreateKey                               "com.apple.iokit.statenotification.create"
+#define kIOStateNotificationItemSetKey                                  "com.apple.iokit.statenotification.set"
+#define kIOStateNotificationItemCopyKey                                 "com.apple.iokit.statenotification.copy"
+
+#define kIOStateNotificationNameKey                                             "com.apple.iokit.statenotification.name"
+#define kIOStateNotificationEntitlementSetKey           "com.apple.iokit.statenotification.entitlement-set"
+#define kIOStateNotificationEntitlementGetKey           "com.apple.iokit.statenotification.entitlement-get"
+
+//
+#define kIOSystemStateClamshellKey      "com.apple.iokit.pm.clamshell"
+
+#define kIOSystemStateSleepDescriptionKey                               "com.apple.iokit.pm.sleepdescription"
+#define kIOSystemStateSleepDescriptionReasonKey                 "com.apple.iokit.pm.sleepreason"
+#define kIOSystemStateSleepDescriptionHibernateStateKey      "com.apple.iokit.pm.hibernatestate"
+
+#define kIOSystemStateWakeDescriptionKey                               "com.apple.iokit.pm.wakedescription"
+#define kIOSystemStateWakeDescriptionWakeReasonKey      "com.apple.iokit.pm.wakereason"
+
+#define kIOSystemStateHaltDescriptionKey                               "com.apple.iokit.pm.haltdescription"
+#define kIOSystemStateHaltDescriptionHaltStateKey      "com.apple.iokit.pm.haltstate"
+
+#define kIOSystemStatePowerSourceDescriptionKey                               "com.apple.iokit.pm.powersourcedescription"
+#define kIOSystemStatePowerSourceDescriptionACAttachedKey      "com.apple.iokit.pm.acattached"
+
+#endif /* ! _IOKIT_IOKITKEYS_H */
diff --git a/iokit/DriverKit/IORPC.h b/iokit/DriverKit/IORPC.h
new file mode 100644
index 00000000..5d49f179
--- /dev/null
+++ b/iokit/DriverKit/IORPC.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2018 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+
+#ifndef _IORPC_H
+#define _IORPC_H
+
+#include <stdint.h>
+
+#ifndef XNU_PLATFORM_DriverKit
+
+#include <mach/message.h>
+
+#else /* !XNU_PLATFORM_DriverKit */
+
+#ifndef _MACH_MESSAGE_H_
+#define _MACH_MESSAGE_H_
+
+#define MACH_MSG_TYPE_MOVE_RECEIVE      16      /* Must hold receive right */
+#define MACH_MSG_TYPE_MOVE_SEND         17      /* Must hold send right(s) */
+#define MACH_MSG_TYPE_MOVE_SEND_ONCE    18      /* Must hold sendonce right */
+#define MACH_MSG_TYPE_COPY_SEND         19      /* Must hold send right(s) */
+#define MACH_MSG_TYPE_MAKE_SEND         20      /* Must hold receive right */
+#define MACH_MSG_TYPE_MAKE_SEND_ONCE    21      /* Must hold receive right */
+#define MACH_MSG_TYPE_COPY_RECEIVE      22      /* NOT VALID */
+#define MACH_MSG_TYPE_DISPOSE_RECEIVE   24      /* must hold receive right */
+#define MACH_MSG_TYPE_DISPOSE_SEND      25      /* must hold send right(s) */
+#define MACH_MSG_TYPE_DISPOSE_SEND_ONCE 26      /* must hold sendonce right */
+
+#define MACH_MSG_TYPE_PORT_NONE         0
+
+#define MACH_MSG_PORT_DESCRIPTOR                0
+#define MACH_MSG_OOL_DESCRIPTOR                 1
+
+typedef unsigned int mach_msg_copy_options_t;
+
+#define MACH_MSG_PHYSICAL_COPY          0
+#define MACH_MSG_VIRTUAL_COPY           1
+#define MACH_MSG_ALLOCATE               2
+
+typedef uint32_t natural_t;
+typedef int32_t integer_t;
+
+typedef unsigned int mach_msg_type_name_t;
+typedef unsigned int mach_msg_descriptor_type_t;
+
+#if KERNEL
+typedef void * mach_port_t;
+#define MACH_PORT_NULL  NULL
+#else /* !KERNEL */
+typedef natural_t mach_port_t;
+#define MACH_PORT_NULL  0
+#endif /* !KERNEL */
+
+typedef natural_t mach_port_name_t;
+
+typedef unsigned int mach_msg_bits_t;
+typedef natural_t mach_msg_size_t;
+typedef integer_t mach_msg_id_t;
+
+#pragma pack(push, 4)
+
+typedef struct{
+	mach_msg_bits_t       msgh_bits;
+	mach_msg_size_t       msgh_size;
+	mach_port_t           msgh_remote_port;
+	mach_port_t           msgh_local_port;
+	mach_port_name_t      msgh_voucher_port;
+	mach_msg_id_t         msgh_id;
+} mach_msg_header_t;
+
+typedef struct{
+	mach_msg_size_t msgh_descriptor_count;
+} mach_msg_body_t;
+
+typedef struct{
+	mach_port_t                   name;
+#if !(defined(KERNEL) && defined(__LP64__))
+// Pad to 8 bytes everywhere except the K64 kernel where mach_port_t is 8 bytes
+	mach_msg_size_t               pad1;
+#endif
+	unsigned int                  pad2 : 16;
+	mach_msg_type_name_t          disposition : 8;
+	mach_msg_descriptor_type_t    type : 8;
+#if defined(KERNEL)
+	uint32_t          pad_end;
+#endif
+} mach_msg_port_descriptor_t;
+
+typedef struct{
+	void *                        address;
+#if !defined(__LP64__)
+	mach_msg_size_t               size;
+#endif
+	int                           deallocate: 8;
+	mach_msg_copy_options_t       copy: 8;
+	unsigned int                  pad1: 8;
+	mach_msg_descriptor_type_t    type: 8;
+#if defined(__LP64__)
+	mach_msg_size_t               size;
+#endif
+#if defined(KERNEL) && !defined(__LP64__)
+	uint32_t          pad_end;
+#endif
+} mach_msg_ool_descriptor_t;
+
+typedef struct{
+	unsigned int                  val[80 / sizeof(int)];
+} mach_msg_max_trailer_t;
+
+#pragma pack(pop)
+
+#endif  /* _MACH_MESSAGE_H_ */
+
+#endif /* XNU_PLATFORM_DriverKit */
+
+#if KERNEL
+class IOUserServer;
+#endif /* KERNEL */
+
+typedef uint64_t OSObjectRef;
+
+enum {
+	kIORPCVersion190615       = (mach_msg_id_t) 0x4da2b68c,
+	kIORPCVersion190615Reply  = (mach_msg_id_t) 0x4da2b68d,
+
+#if DRIVERKIT_PRIVATE
+	kIORPCVersion190501       = (mach_msg_id_t) 0xfe316a7a,
+	kIORPCVersion190501Reply  = (mach_msg_id_t) 0xfe316a7b,
+
+	kIORPCVersionCurrent      = kIORPCVersion190615,
+	kIORPCVersionCurrentReply = kIORPCVersion190615Reply
+#endif /* DRIVERKIT_PRIVATE */
+};
+
+enum{
+	kIORPCMessageRemote     = 0x00000001,
+	kIORPCMessageLocalHost  = 0x00000002,
+	kIORPCMessageKernel     = 0x00000004,
+	kIORPCMessageOneway     = 0x00000008,
+	kIORPCMessageObjectRefs = 0x00000010,
+	kIORPCMessageOnqueue    = 0x00000020,
+	kIORPCMessageError      = 0x00000040,
+	kIORPCMessageSimpleReply = 0x00000080,
+};
+
+enum{
+	kIORPCMessageIDKernel   = (1ULL << 63),
+};
+
+struct IORPCMessageMach {
+	mach_msg_header_t          msgh;
+	mach_msg_body_t            msgh_body;
+	mach_msg_port_descriptor_t objects[0];
+};
+typedef struct IORPCMessageMach IORPCMessageMach;
+
+#pragma pack(push, 4)
+struct IORPCMessage {
+	uint64_t         msgid;
+	uint64_t         flags;
+	uint64_t         objectRefs;
+	OSObjectRef      objects[0];
+};
+#pragma pack(pop)
+typedef struct IORPCMessage IORPCMessage;
+
+#ifndef KERNEL
+
+#if defined(__cplusplus)
+extern "C"
+#else
+extern
+#endif
+IORPCMessage *
+IORPCMessageFromMach(IORPCMessageMach * msg, bool reply);
+
+#endif /* KERNEL */
+
+struct IORPCMessageErrorReturnContent {
+	IORPCMessage  hdr;
+	kern_return_t result;
+	uint32_t      pad;
+};
+typedef struct IORPCMessageErrorReturnContent IORPCMessageErrorReturnContent;
+
+#pragma pack(4)
+struct IORPCMessageErrorReturn {
+	IORPCMessageMach mach;
+	IORPCMessageErrorReturnContent content;
+};
+#pragma pack()
+
+
+#if defined(__cplusplus)
+class OSMetaClassBase;
+struct IORPC;
+typedef kern_return_t (*OSDispatchMethod)(OSMetaClassBase * self, const IORPC rpc);
+#endif
+
+struct IORPC {
+	IORPCMessageMach * message;
+	IORPCMessageMach * reply;
+	uint32_t           sendSize;
+	uint32_t           replySize;
+#ifdef KERNEL
+	IORPCMessage     * kernelContent;
+#endif /* KERNEL */
+};
+typedef struct IORPC IORPC;
+
+enum {
+	kOSClassCanRemote   = 0x00000001,
+};
+
+struct OSClassDescription {
+	uint32_t    descriptionSize;
+
+	char        name[96];
+	char        superName[96];
+
+	uint32_t    methodOptionsSize;
+	uint32_t    methodOptionsOffset;
+	uint32_t    metaMethodOptionsSize;
+	uint32_t    metaMethodOptionsOffset;
+	uint32_t    queueNamesSize;
+	uint32_t    queueNamesOffset;
+	uint32_t    methodNamesSize;
+	uint32_t    methodNamesOffset;
+	uint32_t    metaMethodNamesSize;
+	uint32_t    metaMethodNamesOffset;
+
+	uint64_t    flags;
+
+	uint64_t    resv1[8];
+
+	uint64_t    methodOptions[0];
+	uint64_t    metaMethodOptions[0];
+
+	char        dispatchNames[0];
+	char        methodNames[0];
+	char        metaMethodNames[0];
+};
+
+IORPCMessage *IORPCMessageFromMach(IORPCMessageMach * msg, bool reply);
+
+#endif /* _IORPC_H */
diff --git a/iokit/DriverKit/IOReportTypes.h b/iokit/DriverKit/IOReportTypes.h
new file mode 100644
index 00000000..dd81759a
--- /dev/null
+++ b/iokit/DriverKit/IOReportTypes.h
@@ -0,0 +1,411 @@
+/*
+ * Copyright (c) 2012-2014 Apple Computer, Inc.  All Rights Reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef _IOREPORT_TYPES_H_
+#define _IOREPORT_TYPES_H_
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IOR_VALUES_PER_ELEMENT  4
+
+/*! @const      kIOReportInvalidValue
+ *   @const      kIOReportInvalidIntValue
+ *   @abstract   cardinal value used to indicate data errors
+ *
+ *   @discussion
+ *       kIOReportInvalidValue and kIOReportInvalidIntValue have the
+ *       same bit pattern so that clients checking for one or the other
+ *       don't have to worry about getting the signedness right.
+ */
+#define kIOReportInvalidIntValue INT64_MIN
+#define kIOReportInvalidValue (uint64_t)kIOReportInvalidIntValue
+
+/*! @typedef    IOReportCategories
+ *   @abstract   encapsulate important, multi-purpose "tags" for channels
+ *
+ *   @discussion
+ *       IOReportCategories is the type for the .categories field of
+ *       IOReportChanelType.  These categories are inteded to empower a
+ *       limited number of clients to retrieve a broad range of channels
+ *       without knowing much about them.  They can be OR'd together as
+ *       needed.  Groups and subgroups are a more extensible mechanism
+ *       for aggregating channels produced by different drivers.
+ */
+typedef uint16_t IOReportCategories;
+#define kIOReportCategoryPower           (1 << 1)       // and energy
+#define kIOReportCategoryTraffic         (1 << 2)       // I/O at any level
+#define kIOReportCategoryPerformance     (1 << 3)       // e.g. cycles/byte
+#define kIOReportCategoryPeripheral      (1 << 4)       // not built-in
+
+#define kIOReportCategoryField           (1 << 8)       // consider logging
+
+// future categories TBD
+#define kIOReportCategoryDebug           (1 << 15)
+#define kIOReportInvalidCategory         UINT16_MAX
+
+
+// IOReportChannelType.report_format
+typedef uint8_t IOReportFormat;
+enum {
+	kIOReportInvalidFormat = 0,
+	kIOReportFormatSimple = 1,
+	kIOReportFormatState = 2,
+	kIOReportFormatHistogram = 3,
+	kIOReportFormatSimpleArray = 4
+};
+
+// simple report values
+typedef struct {
+	int64_t    simple_value;
+	uint64_t    reserved1;
+	uint64_t    reserved2;
+	uint64_t    reserved3;
+} __attribute((packed)) IOSimpleReportValues;
+
+// simple value array
+typedef struct {
+	int64_t    simple_values[IOR_VALUES_PER_ELEMENT];
+} __attribute((packed)) IOSimpleArrayReportValues;
+
+// state report values
+typedef struct {
+	uint64_t    state_id;       // 0..N-1 or 8-char code (see MAKEID())
+	uint64_t    intransitions;  // number of transitions into this state
+	uint64_t    upticks;        // ticks spent in state (local timebase)
+	uint64_t    last_intransition;// ticks at last in-transition
+} __attribute((packed)) IOStateReportValues;
+
+// histogram report values
+typedef struct {
+	uint64_t    bucket_hits;
+	int64_t     bucket_min;
+	int64_t     bucket_max;
+	int64_t     bucket_sum;
+} __attribute((packed)) IOHistogramReportValues;
+
+
+
+// configuration actions generally change future behavior
+typedef uint32_t IOReportConfigureAction;
+enum {
+	// basics (in common operational order)
+	kIOReportEnable             = 0x01,
+	kIOReportGetDimensions      = 0x02,
+	kIOReportDisable            = 0x00,
+
+	// Enable/disable modifiers
+	kIOReportNotifyHubOnChange  = 0x10, // triggered polling
+
+	kIOReportTraceOnChange      = 0x20  // kdebug.h tracing
+};
+
+// update actions should not have observable side effects
+typedef uint32_t IOReportUpdateAction;
+enum {
+	kIOReportCopyChannelData    = 1,
+	kIOReportTraceChannelData   = 2
+};
+
+typedef struct {
+	uint8_t     report_format;  // Histogram, StateResidency, etc.
+	uint8_t     reserved;       // must be zero
+	uint16_t    categories;     // power, traffic, etc (omnibus obs.)
+	uint16_t    nelements;      // internal size of channel
+
+	// only meaningful in the data pipeline
+	int16_t     element_idx;    // 0..nelements-1
+	                            // -1..-(nelements) = invalid (13127884)
+} __attribute((packed)) IOReportChannelType;
+
+/*!
+ *   @define     IOREPORT_MAKECHID
+ *   @abstract   convert up to 8 printable characters into a 64-bit channel ID
+ *   @param  <char0..char7> - printable chars to be packed into a channel ID
+ *   @result     a 64-bit channel ID with an implicit ASCII name
+ *   @discussion A simple example:
+ *               IOREPORT_MAKECHID('H', 'i', ' ', 'w', 'o', 'r', 'l', 'd');
+ *               will evaluate to 0x686920776f726c64.  Any NUL bytes are
+ *               ignored (by libIOReport) for naming purposes, but will
+ *               appear in the channel ID.  Using a non-NUL non-printable
+ *               character will disable the implicit name.  Putting NUL
+ *               bytes first eliminates trailing zeros when the channel
+ *               ID is printed as hex.  For example:
+ *               IORERPORT_MAKECHID('\0','\0','n','x','f','e','r','s');
+ *               To see the text, use xxd -r -p # not -rp; see 12976241
+ */
+#define __IOR_lshiftchr(c, chshift)     ((uint64_t)(c) << (8*(chshift)))
+#define IOREPORT_MAKEID(A, B, C, D, E, F, G, H) \
+    (__IOR_lshiftchr(A, 7) | __IOR_lshiftchr(B, 6) | __IOR_lshiftchr(C, 5) \
+    | __IOR_lshiftchr(D, 4) | __IOR_lshiftchr(E, 3) | __IOR_lshiftchr(F, 2) \
+    | __IOR_lshiftchr(G, 1) | __IOR_lshiftchr(H, 0))
+
+typedef struct {
+	uint64_t                channel_id;
+	IOReportChannelType     channel_type;
+} IOReportChannel;
+
+typedef struct {
+	uint32_t                nchannels;
+	IOReportChannel         channels[];
+} IOReportChannelList;
+
+typedef struct {
+	uint64_t                provider_id;
+	IOReportChannel         channel;
+} IOReportInterest;
+
+typedef struct {
+	uint32_t                ninterests;
+	IOReportInterest        interests[];
+} IOReportInterestList;
+
+typedef struct {
+	uint64_t                v[IOR_VALUES_PER_ELEMENT];
+} __attribute((packed)) IOReportElementValues;
+
+typedef struct {
+	uint64_t                provider_id;
+	uint64_t                channel_id;
+	IOReportChannelType     channel_type;
+	uint64_t                timestamp;// mach_absolute_time()
+	IOReportElementValues   values;
+} __attribute((packed)) IOReportElement;
+
+
+
+/*
+ *  IOReporting unit type and constants
+ */
+
+// 1. Mechanism
+
+// Assume encoded units could be stored in binary format: don't
+// change existing values.
+
+typedef uint64_t IOReportUnit;
+typedef uint64_t IOReportUnits;     // deprecated typo, please switch
+#define __IOR_MAKEUNIT(quantity, scale) \
+	(((IOReportUnit)quantity << 56) | (uint64_t)scale)
+#define IOREPORT_GETUNIT_QUANTITY(unit) \
+	((IOReportQuantity)((uint64_t)unit >> 56) & 0xff)
+#define IOREPORT_GETUNIT_SCALE(unit) \
+	((IOReportScaleFactor)unit & 0x00ffffffffffffff)
+
+// 8b quantity ID | 32b const val + 8b*2^10 + 8b*2^n | 8b cardinal | 8b unused
+typedef uint8_t IOReportQuantity;       // SI "quantity" is what's measured
+typedef uint64_t IOReportScaleFactor;
+
+// See <http://en.wikipedia.org/wiki/SI_base_unit> for a list
+// of quantities and their symbols.
+enum {
+	// used by state reports, etc
+	kIOReportQuantityUndefined = 0,
+
+	kIOReportQuantityTime           = 1,// Seconds
+	kIOReportQuantityPower          = 2,// Watts
+	kIOReportQuantityEnergy         = 3,// Joules
+	kIOReportQuantityCurrent        = 4,// Amperes
+	kIOReportQuantityVoltage        = 5,// Volts
+	kIOReportQuantityCapacitance    = 6,// Farad
+	kIOReportQuantityInductance     = 7,// Henry
+	kIOReportQuantityFrequency      = 8,// Hertz
+	kIOReportQuantityData           = 9,// bits/bytes (see scale)
+	kIOReportQuantityTemperature    = 10,// Celsius (not Kelvin :)
+
+	kIOReportQuantityEventCount     = 100,
+	kIOReportQuantityPacketCount    = 101,
+	kIOReportQuantityCPUInstrs      = 102
+};
+
+
+/* A number of units end up with both IEC (2^n) and SI (10^n) scale factors.
+ *  For example, the "MB" of a 1.44 MB floppy or a 1024MHz clock.  We
+ *  thus support separate 2^n and 10^n factors.  The exponent encoding
+ *  scheme is modeled loosely on single-precision IEEE 754.
+ */
+#define kIOReportScaleConstMask 0x000000007fffffff      // constant ("uint31")
+#define kIOReportScaleOneOver   (1LL << 31)             // 1/constant
+#define kIOReportExpBase        (-127)                  // support base^(-n)
+#define kIOReportExpZeroOffset  -(kIOReportExpBase)     // max exponent = 128
+#define kIOReportScaleSIShift   32                      // * 10^n
+#define kIOReportScaleSIMask    0x000000ff00000000
+#define kIOReportScaleIECShift  40                      // * 2^n
+#define kIOReportScaleIECMask   0x0000ff0000000000
+#define kIOReportCardinalShift  48                      // placeholders
+#define kIOReportCardinalMask   0x00ff000000000000
+
+
+/*
+ *  Scales are described as a factor times unity:
+ *  1ms = kIOReportScaleMilli * s
+ *
+ *  A value expressed in a scaled unit can be scaled to unity via
+ *  multiplication by the constant:
+ *  100ms * kIOReportScaleMilli [1e-3] = 0.1s.
+ */
+
+// SI / decimal
+#define kIOReportScalePico  ((-12LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+#define kIOReportScaleNano  ((-9LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+#define kIOReportScaleMicro ((-6LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+#define kIOReportScaleMilli ((-3LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+#define kIOReportScaleUnity 0    // 10^0 = 2^0 = 1
+// unity = 0 is a special case for which we give up exp = -127
+#define kIOReportScaleKilo  ((3LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+#define kIOReportScaleMega  ((6LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+#define kIOReportScaleGiga  ((9LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+#define kIOReportScaleTera  ((12LL + kIOReportExpZeroOffset)  \
+	                                << kIOReportScaleSIShift)
+
+// IEC / computer / binary
+// It's not clear we'll ever use 2^(-n), but 1..2^~120 should suffice.
+#define kIOReportScaleBits  kIOReportScaleUnity
+#define kIOReportScaleBytes     ((3LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+// (bytes have to be added to the exponents up front, can't just OR in)
+#define kIOReportScaleKibi      ((10LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+#define kIOReportScaleKiBytes   ((13LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+#define kIOReportScaleMebi      ((20LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+#define kIOReportScaleMiBytes   ((23LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+#define kIOReportScaleGibi      ((30LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+#define kIOReportScaleGiBytes   ((33LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+#define kIOReportScaleTebi      ((40LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+#define kIOReportScaleTiBytes   ((43LL + kIOReportExpZeroOffset)  \
+	                                    << kIOReportScaleIECShift)
+// can't encode more than 2^125 (keeping bits & bytes inside -126..128)
+// Also, IOReportScaleValue() is currently limited internally by uint64_t.
+
+
+// Cardinal values, to be filled in appropriately.
+// Add values in increasing order.
+#define kIOReportScaleMachHWTicks   (1LL << kIOReportCardinalShift)
+#define kIOReportScaleHWPageSize    (2LL << kIOReportCardinalShift)
+
+// page scales: 2 pages * 4ikB/page = 8096 bytes
+#define kIOReportScale4KiB      (4 | kIOReportScaleKiBytes)
+#define kIOReportScale8KiB      (8 | kIOReportScaleKiBytes)
+#define kIOReportScale16KiB     (16 | kIOReportScaleKiBytes)
+
+// Clock frequency scales (units add seconds).
+// 1 GHz ticks are 1 ns: 1000 ticks * 1e-6 = 1e-3s
+// This '1' is a no-op for scaling, but allows a custom label.
+#define kIOReportScale1GHz      (1 | kIOReportScaleNano)
+// 24MHz ticks are 1/24 of a microsecond: (1/24 * kIOReportScaleMicro [1e-6])s
+// So for example, 240 24Mticks * 1/24 * 1e-6 = .00001s [1e-5]s
+#define kIOReportScale24MHz     (kIOReportScaleOneOver|24 |kIOReportScaleMicro)
+
+// --- END: units mechanism
+
+
+// 2. Unit constants
+#define kIOReportUnitNone       __IOR_MAKEUNIT(kIOReportQuantityUndefined,  \
+	                                          kIOReportScaleUnity)
+
+#define kIOReportUnit_s         __IOR_MAKEUNIT(kIOReportQuantityTime,  \
+	                                       kIOReportScaleUnity)
+#define kIOReportUnit_ms        __IOR_MAKEUNIT(kIOReportQuantityTime,  \
+	                                       kIOReportScaleMilli)
+#define kIOReportUnit_us        __IOR_MAKEUNIT(kIOReportQuantityTime,  \
+	                                       kIOReportScaleMicro)
+#define kIOReportUnit_ns        __IOR_MAKEUNIT(kIOReportQuantityTime,  \
+	                                       kIOReportScaleNano)
+
+#define kIOReportUnit_J         __IOR_MAKEUNIT(kIOReportQuantityEnergy,  \
+	                                       kIOReportScaleUnity)
+#define kIOReportUnit_mJ        __IOR_MAKEUNIT(kIOReportQuantityEnergy,  \
+	                                       kIOReportScaleMilli)
+#define kIOReportUnit_uJ        __IOR_MAKEUNIT(kIOReportQuantityEnergy,  \
+	                                       kIOReportScaleMicro)
+#define kIOReportUnit_nJ        __IOR_MAKEUNIT(kIOReportQuantityEnergy,  \
+	                                       kIOReportScaleNano)
+#define kIOReportUnit_pJ        __IOR_MAKEUNIT(kIOReportQuantityEnergy,  \
+	                                       kIOReportScalePico)
+
+#define kIOReportUnitHWTicks    __IOR_MAKEUNIT(kIOReportQuantityTime,  \
+	                                       kIOReportScaleMachHWTicks)
+#define kIOReportUnit24MHzTicks __IOR_MAKEUNIT(kIOReportQuantityTime,  \
+	                                       kIOReportScale24MHz)
+#define kIOReportUnit1GHzTicks  __IOR_MAKEUNIT(kIOReportQuantityTime,  \
+	                                       kIOReportScale1GHz)
+
+#define kIOReportUnitBits       __IOR_MAKEUNIT(kIOReportQuantityData,  \
+	                                        kIOReportScaleBits)
+#define kIOReportUnitBytes      __IOR_MAKEUNIT(kIOReportQuantityData,  \
+	                                        kIOReportScaleBytes)
+#define kIOReportUnit_KiB       __IOR_MAKEUNIT(kIOReportQuantityData,  \
+	                                       kIOReportScaleKiBytes)
+#define kIOReportUnit_MiB       __IOR_MAKEUNIT(kIOReportQuantityData,  \
+	                                       kIOReportScaleMiBytes)
+#define kIOReportUnit_GiB       __IOR_MAKEUNIT(kIOReportQuantityData,  \
+	                                       kIOReportScaleGiBytes)
+#define kIOReportUnit_TiB       __IOR_MAKEUNIT(kIOReportQuantityData,  \
+	                                       kIOReportScaleTiBytes)
+
+#define kIOReportUnitEvents     __IOR_MAKEUNIT(kIOReportQuantityEventCount,  \
+	                                       kIOReportScaleUnity)
+
+#define kIOReportUnitPackets    __IOR_MAKEUNIT(kIOReportQuantityPacketCount,  \
+	                                       kIOReportScaleUnity)
+
+#define kIOReportUnitInstrs     __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  \
+	                                       kIOReportScaleUnity)
+#define kIOReportUnit_KI        __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  \
+	                                       kIOReportScaleKilo)
+#define kIOReportUnit_MI        __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  \
+	                                       kIOReportScaleMega)
+#define kIOReportUnit_GI        __IOR_MAKEUNIT(kIOReportQuantityCPUInstrs,  \
+	                                       kIOReportScaleGiga)
+
+// Please file bugs (xnu | IOReporting) for additional units.
+
+// --- END: unit constants
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _IOREPORT_TYPES_H_
diff --git a/iokit/DriverKit/IOReturn.h b/iokit/DriverKit/IOReturn.h
new file mode 100644
index 00000000..71f6b40f
--- /dev/null
+++ b/iokit/DriverKit/IOReturn.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+/*
+ * HISTORY
+ */
+
+/*
+ * Core IOReturn values. Others may be family defined.
+ */
+
+#ifndef __IOKIT_IORETURN_H
+#define __IOKIT_IORETURN_H
+
+#include <IOKit/IORPC.h>
+IORPCMessage *
+IORPCMessageFromMach(IORPCMessageMach * msg, bool reply);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef XNU_PLATFORM_DriverKit
+
+#include <mach/error.h>
+
+#else  /* XNU_PLATFORM_DriverKit */
+
+#ifdef DRIVERKIT_PRIVATE
+
+#include <mach/error.h>
+
+#else  /* DRIVERKIT_PRIVATE */
+
+typedef int             kern_return_t;
+
+#define KERN_SUCCESS                    0
+
+/*
+ *	error number layout as follows:
+ *
+ *	hi		                       lo
+ *	| system(6) | subsystem(12) | code(14) |
+ */
+
+#define err_none                (kern_return_t)0
+#define ERR_SUCCESS             (kern_return_t)0
+
+#define err_system(x)           ((signed)((((unsigned)(x))&0x3f)<<26))
+#define err_sub(x)              (((x)&0xfff)<<14)
+
+#define err_get_system(err)     (((err)>>26)&0x3f)
+#define err_get_sub(err)        (((err)>>14)&0xfff)
+#define err_get_code(err)       ((err)&0x3fff)
+
+#define err_max_system          0x3f
+
+#define system_emask            (err_system(err_max_system))
+#define sub_emask               (err_sub(0xfff))
+#define code_emask              (0x3fff)
+
+#endif  /* DRIVERKIT_PRIVATE */
+
+#endif /* XNU_PLATFORM_DriverKit */
+
+typedef kern_return_t           IOReturn;
+
+#ifndef sys_iokit
+#define sys_iokit                         err_system(0x38)
+#endif /* sys_iokit */
+#define sub_iokit_common                  err_sub(0)
+#define sub_iokit_usb                     err_sub(1)
+#define sub_iokit_firewire                err_sub(2)
+#define sub_iokit_block_storage           err_sub(4)
+#define sub_iokit_graphics                err_sub(5)
+#define sub_iokit_networking              err_sub(6)
+#define sub_iokit_bluetooth               err_sub(8)
+#define sub_iokit_pmu                     err_sub(9)
+#define sub_iokit_acpi                    err_sub(10)
+#define sub_iokit_smbus                   err_sub(11)
+#define sub_iokit_ahci                    err_sub(12)
+#define sub_iokit_powermanagement         err_sub(13)
+#define sub_iokit_hidsystem               err_sub(14)
+#define sub_iokit_scsi                    err_sub(16)
+#define sub_iokit_usbaudio                err_sub(17)
+#define sub_iokit_wirelesscharging        err_sub(18)
+//#define sub_iokit_pccard                err_sub(21)
+#ifdef PRIVATE
+#define sub_iokit_nvme                    err_sub(28)
+#endif
+#define sub_iokit_thunderbolt             err_sub(29)
+#define sub_iokit_graphics_acceleration   err_sub(30)
+#define sub_iokit_keystore                err_sub(31)
+#ifdef PRIVATE
+#define sub_iokit_smc                     err_sub(32)
+#endif
+#define sub_iokit_apfs                    err_sub(33)
+#define sub_iokit_acpiec                  err_sub(34)
+#define sub_iokit_timesync_avb            err_sub(35)
+
+#define sub_iokit_platform                err_sub(0x2A)
+#define sub_iokit_audio_video             err_sub(0x45)
+#define sub_iokit_cec                     err_sub(0x46)
+#define sub_iokit_arc                     err_sub(0x47)
+#define sub_iokit_baseband                err_sub(0x80)
+#define sub_iokit_HDA                     err_sub(0xFE)
+#define sub_iokit_hsic                    err_sub(0x147)
+#define sub_iokit_sdio                    err_sub(0x174)
+#define sub_iokit_wlan                    err_sub(0x208)
+#define sub_iokit_appleembeddedsleepwakehandler  err_sub(0x209)
+#define sub_iokit_appleppm                err_sub(0x20A)
+
+#define sub_iokit_vendor_specific         err_sub(-2)
+#define sub_iokit_reserved                err_sub(-1)
+
+#define iokit_common_err(return )          (sys_iokit|sub_iokit_common|return)
+#define iokit_family_err(sub, return )      (sys_iokit|sub|return)
+#define iokit_vendor_specific_err(return ) (sys_iokit|sub_iokit_vendor_specific|return)
+
+#define kIOReturnSuccess         KERN_SUCCESS            // OK
+#define kIOReturnError           iokit_common_err(0x2bc) // general error
+#define kIOReturnNoMemory        iokit_common_err(0x2bd) // can't allocate memory
+#define kIOReturnNoResources     iokit_common_err(0x2be) // resource shortage
+#define kIOReturnIPCError        iokit_common_err(0x2bf) // error during IPC
+#define kIOReturnNoDevice        iokit_common_err(0x2c0) // no such device
+#define kIOReturnNotPrivileged   iokit_common_err(0x2c1) // privilege violation
+#define kIOReturnBadArgument     iokit_common_err(0x2c2) // invalid argument
+#define kIOReturnLockedRead      iokit_common_err(0x2c3) // device read locked
+#define kIOReturnLockedWrite     iokit_common_err(0x2c4) // device write locked
+#define kIOReturnExclusiveAccess iokit_common_err(0x2c5) // exclusive access and
+                                                         //   device already open
+#define kIOReturnBadMessageID    iokit_common_err(0x2c6) // sent/received messages
+                                                         //   had different msg_id
+#define kIOReturnUnsupported     iokit_common_err(0x2c7) // unsupported function
+#define kIOReturnVMError         iokit_common_err(0x2c8) // misc. VM failure
+#define kIOReturnInternalError   iokit_common_err(0x2c9) // internal error
+#define kIOReturnIOError         iokit_common_err(0x2ca) // General I/O error
+//#define kIOReturn???Error      iokit_common_err(0x2cb) // ???
+#define kIOReturnCannotLock      iokit_common_err(0x2cc) // can't acquire lock
+#define kIOReturnNotOpen         iokit_common_err(0x2cd) // device not open
+#define kIOReturnNotReadable     iokit_common_err(0x2ce) // read not supported
+#define kIOReturnNotWritable     iokit_common_err(0x2cf) // write not supported
+#define kIOReturnNotAligned      iokit_common_err(0x2d0) // alignment error
+#define kIOReturnBadMedia        iokit_common_err(0x2d1) // Media Error
+#define kIOReturnStillOpen       iokit_common_err(0x2d2) // device(s) still open
+#define kIOReturnRLDError        iokit_common_err(0x2d3) // rld failure
+#define kIOReturnDMAError        iokit_common_err(0x2d4) // DMA failure
+#define kIOReturnBusy            iokit_common_err(0x2d5) // Device Busy
+#define kIOReturnTimeout         iokit_common_err(0x2d6) // I/O Timeout
+#define kIOReturnOffline         iokit_common_err(0x2d7) // device offline
+#define kIOReturnNotReady        iokit_common_err(0x2d8) // not ready
+#define kIOReturnNotAttached     iokit_common_err(0x2d9) // device not attached
+#define kIOReturnNoChannels      iokit_common_err(0x2da) // no DMA channels left
+#define kIOReturnNoSpace         iokit_common_err(0x2db) // no space for data
+//#define kIOReturn???Error      iokit_common_err(0x2dc) // ???
+#define kIOReturnPortExists      iokit_common_err(0x2dd) // port already exists
+#define kIOReturnCannotWire      iokit_common_err(0x2de) // can't wire down
+                                                         //   physical memory
+#define kIOReturnNoInterrupt     iokit_common_err(0x2df) // no interrupt attached
+#define kIOReturnNoFrames        iokit_common_err(0x2e0) // no DMA frames enqueued
+#define kIOReturnMessageTooLarge iokit_common_err(0x2e1) // oversized msg received
+                                                         //   on interrupt port
+#define kIOReturnNotPermitted    iokit_common_err(0x2e2) // not permitted
+#define kIOReturnNoPower         iokit_common_err(0x2e3) // no power to device
+#define kIOReturnNoMedia         iokit_common_err(0x2e4) // media not present
+#define kIOReturnUnformattedMedia iokit_common_err(0x2e5)// media not formatted
+#define kIOReturnUnsupportedMode iokit_common_err(0x2e6) // no such mode
+#define kIOReturnUnderrun        iokit_common_err(0x2e7) // data underrun
+#define kIOReturnOverrun         iokit_common_err(0x2e8) // data overrun
+#define kIOReturnDeviceError     iokit_common_err(0x2e9) // the device is not working properly!
+#define kIOReturnNoCompletion    iokit_common_err(0x2ea) // a completion routine is required
+#define kIOReturnAborted         iokit_common_err(0x2eb) // operation aborted
+#define kIOReturnNoBandwidth     iokit_common_err(0x2ec) // bus bandwidth would be exceeded
+#define kIOReturnNotResponding   iokit_common_err(0x2ed) // device not responding
+#define kIOReturnIsoTooOld       iokit_common_err(0x2ee) // isochronous I/O request for distant past!
+#define kIOReturnIsoTooNew       iokit_common_err(0x2ef) // isochronous I/O request for distant future
+#define kIOReturnNotFound        iokit_common_err(0x2f0) // data was not found
+#define kIOReturnInvalid         iokit_common_err(0x1)   // should never be seen
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ! __IOKIT_IORETURN_H */
diff --git a/iokit/DriverKit/IOTypes.h b/iokit/DriverKit/IOTypes.h
new file mode 100644
index 00000000..661b05e7
--- /dev/null
+++ b/iokit/DriverKit/IOTypes.h
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 1998-2012 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+#ifndef __IOKIT_IOTYPES_H
+#define __IOKIT_IOTYPES_H
+
+#ifndef XNU_PLATFORM_DriverKit
+
+#ifndef IOKIT
+#define IOKIT 1
+#endif /* !IOKIT */
+
+#include <sys/cdefs.h>
+
+#if KERNEL
+#include <IOKit/system.h>
+#else
+#include <mach/message.h>
+#include <mach/vm_types.h>
+#endif
+
+#include <IOKit/IOReturn.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef NULL
+#if defined (__cplusplus)
+#ifdef XNU_KERNEL_PRIVATE
+#define NULL nullptr
+#else
+#if __cplusplus >= 201103L && (defined(__arm__) || defined(__arm64__))
+#define NULL nullptr
+#else
+#define NULL    0
+#endif
+#endif
+#else
+#define NULL ((void *)0)
+#endif
+#endif
+
+/*
+ * Simple data types.
+ */
+#include <stdbool.h>
+#include <libkern/OSTypes.h>
+
+#if KERNEL
+#include <libkern/OSBase.h>
+#endif
+
+typedef UInt32          IOOptionBits;
+typedef SInt32          IOFixed;
+typedef UInt32          IOVersion;
+typedef UInt32          IOItemCount;
+typedef UInt32          IOCacheMode;
+
+typedef UInt32          IOByteCount32;
+typedef UInt64          IOByteCount64;
+
+typedef UInt32  IOPhysicalAddress32;
+typedef UInt64  IOPhysicalAddress64;
+typedef UInt32  IOPhysicalLength32;
+typedef UInt64  IOPhysicalLength64;
+
+#if !defined(__arm__) && !defined(__i386__)
+typedef mach_vm_address_t       IOVirtualAddress __kernel_ptr_semantics;
+#else
+typedef vm_address_t            IOVirtualAddress __kernel_ptr_semantics;
+#endif
+
+#if !defined(__arm__) && !defined(__i386__) && !(defined(__x86_64__) && !defined(KERNEL)) && !(defined(__arm64__) && !defined(__LP64__))
+typedef IOByteCount64           IOByteCount;
+#define PRIIOByteCount                  PRIu64
+#else
+typedef IOByteCount32           IOByteCount;
+#define PRIIOByteCount                  PRIu32
+#endif
+
+typedef IOVirtualAddress    IOLogicalAddress;
+
+#if !defined(__arm__) && !defined(__i386__) && !(defined(__x86_64__) && !defined(KERNEL))
+
+typedef IOPhysicalAddress64      IOPhysicalAddress;
+typedef IOPhysicalLength64       IOPhysicalLength;
+#define IOPhysical32( hi, lo )          ((UInt64) lo + ((UInt64)(hi) << 32))
+#define IOPhysSize      64
+
+#else
+
+typedef IOPhysicalAddress32      IOPhysicalAddress;
+typedef IOPhysicalLength32       IOPhysicalLength;
+#define IOPhysical32( hi, lo )          (lo)
+#define IOPhysSize      32
+
+#endif
+
+
+typedef struct{
+	IOPhysicalAddress   address;
+	IOByteCount         length;
+} IOPhysicalRange;
+
+typedef struct{
+	IOVirtualAddress    address;
+	IOByteCount         length;
+} IOVirtualRange;
+
+#if !defined(__arm__) && !defined(__i386__)
+typedef IOVirtualRange  IOAddressRange;
+#else
+typedef struct{
+	mach_vm_address_t   address;
+	mach_vm_size_t      length;
+} IOAddressRange;
+#endif
+
+/*
+ * Map between #defined or enum'd constants and text description.
+ */
+typedef struct {
+	int value;
+	const char *name;
+} IONamedValue;
+
+
+/*
+ * Memory alignment -- specified as a power of two.
+ */
+typedef unsigned int    IOAlignment;
+
+#define IO_NULL_VM_TASK         ((vm_task_t)0)
+
+
+/*
+ * Pull in machine specific stuff.
+ */
+
+//#include <IOKit/machine/IOTypes.h>
+
+#ifndef MACH_KERNEL
+
+#ifndef __IOKIT_PORTS_DEFINED__
+#define __IOKIT_PORTS_DEFINED__
+#ifdef KERNEL
+#ifdef __cplusplus
+class OSObject;
+typedef OSObject * io_object_t;
+#else
+typedef struct OSObject * io_object_t;
+#endif
+#else /* KERNEL */
+typedef mach_port_t     io_object_t;
+#endif /* KERNEL */
+#endif /* __IOKIT_PORTS_DEFINED__ */
+
+#include <device/device_types.h>
+
+typedef io_object_t     io_connect_t;
+typedef io_object_t     io_enumerator_t;
+typedef io_object_t     io_ident_t;
+typedef io_object_t     io_iterator_t;
+typedef io_object_t     io_registry_entry_t;
+typedef io_object_t     io_service_t;
+typedef io_object_t     uext_object_t;
+
+#define IO_OBJECT_NULL  ((io_object_t) 0)
+
+#endif /* MACH_KERNEL */
+
+#include <IOKit/IOMapTypes.h>
+
+/*! @enum Scale Factors
+ *   @discussion Used when a scale_factor parameter is required to define a unit of time.
+ *   @constant kNanosecondScale Scale factor for nanosecond based times.
+ *   @constant kMicrosecondScale Scale factor for microsecond based times.
+ *   @constant kMillisecondScale Scale factor for millisecond based times.
+ *   @constant kTickScale Scale factor for the standard (100Hz) tick.
+ *   @constant kSecondScale Scale factor for second based times. */
+
+enum {
+	kNanosecondScale  = 1,
+	kMicrosecondScale = 1000,
+	kMillisecondScale = 1000 * 1000,
+	kSecondScale      = 1000 * 1000 * 1000,
+	kTickScale        = (kSecondScale / 100)
+};
+
+enum {
+	kIOConnectMethodVarOutputSize = -3
+};
+
+/* compatibility types */
+
+#ifndef KERNEL
+
+typedef unsigned int IODeviceNumber;
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#else /* !XNU_PLATFORM_DriverKit */
+
+#include <stdint.h>
+
+typedef uint32_t          IOOptionBits;
+typedef int32_t           IOFixed;
+typedef uint32_t          IOVersion;
+typedef uint32_t          IOItemCount;
+typedef uint32_t          IOCacheMode;
+
+typedef uint32_t          IOByteCount32;
+typedef uint64_t          IOByteCount64;
+typedef IOByteCount64     IOByteCount;
+
+typedef uint32_t  IOPhysicalAddress32;
+typedef uint64_t  IOPhysicalAddress64;
+typedef uint32_t  IOPhysicalLength32;
+typedef uint64_t  IOPhysicalLength64;
+
+typedef IOPhysicalAddress64      IOPhysicalAddress;
+typedef IOPhysicalLength64       IOPhysicalLength;
+
+typedef uint64_t       IOVirtualAddress;
+
+#endif /* XNU_PLATFORM_DriverKit */
+
+enum {
+	kIOMaxBusStall40usec = 40000,
+	kIOMaxBusStall30usec = 30000,
+	kIOMaxBusStall25usec = 25000,
+	kIOMaxBusStall20usec = 20000,
+	kIOMaxBusStall10usec = 10000,
+	kIOMaxBusStall5usec  = 5000,
+	kIOMaxBusStallNone   = 0,
+};
+
+#if PRIVATE
+#define LIBKERN_OSNUMBER_FLOAT_SUPPORT          1
+#endif /* PRIVATE */
+
+#endif /* ! __IOKIT_IOTYPES_H */
diff --git a/iokit/DriverKit/OSBoundedArray.h b/iokit/DriverKit/OSBoundedArray.h
new file mode 100644
index 00000000..e413229b
--- /dev/null
+++ b/iokit/DriverKit/OSBoundedArray.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2019 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_H
+#define XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_H
+
+#if !TAPI
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/bounded_array.h>
+#include <DriverKit/OSBoundedPtr.h>
+#else
+#include <libkern/c++/bounded_array.h>
+#include <libkern/c++/OSBoundedPtr.h>
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+#include <stddef.h>
+
+template <typename T, size_t N>
+using OSBoundedArray = libkern::bounded_array<T, N, os_detail::panic_trapping_policy>;
+
+#endif /* !TAPI */
+
+#endif /* !XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_H */
diff --git a/iokit/DriverKit/OSBoundedArrayRef.h b/iokit/DriverKit/OSBoundedArrayRef.h
new file mode 100644
index 00000000..4467f6b6
--- /dev/null
+++ b/iokit/DriverKit/OSBoundedArrayRef.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2019 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_REF_H
+#define XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_REF_H
+
+#if !TAPI
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/bounded_array_ref.h>
+#include <DriverKit/OSBoundedPtr.h>
+#else
+#include <libkern/c++/bounded_array_ref.h>
+#include <libkern/c++/OSBoundedPtr.h>
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+
+
+template <typename T>
+using OSBoundedArrayRef = libkern::bounded_array_ref<T, os_detail::panic_trapping_policy>;
+
+#endif /* !TAPI */
+
+#endif /* !XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_ARRAY_REF_H */
diff --git a/iokit/DriverKit/OSBoundedPtr.h b/iokit/DriverKit/OSBoundedPtr.h
new file mode 100644
index 00000000..6ea9b134
--- /dev/null
+++ b/iokit/DriverKit/OSBoundedPtr.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2019 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_H
+#define XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_H
+
+#if !TAPI
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/IOLib.h>
+#include <DriverKit/OSBoundedPtrFwd.h>
+#if __cplusplus >= 201703L
+#include <DriverKit/bounded_ptr.h>
+#endif /* __cplusplus >= 201703L */
+#else
+#include <kern/debug.h>
+#include <libkern/c++/OSBoundedPtrFwd.h>
+#if __cplusplus >= 201703L
+#include <libkern/c++/bounded_ptr.h>
+#endif /* __cplusplus >= 201703L */
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+
+namespace os_detail {
+struct panic_trapping_policy {
+	[[noreturn]] static void
+	trap(char const* message)
+	{
+		panic("%s", message);
+	}
+};
+}
+
+// OSBoundedPtr alias is defined in the fwd decl header
+
+#endif /* !TAPI */
+
+#endif /* !XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_H */
diff --git a/iokit/DriverKit/OSBoundedPtrFwd.h b/iokit/DriverKit/OSBoundedPtrFwd.h
new file mode 100644
index 00000000..04c4df48
--- /dev/null
+++ b/iokit/DriverKit/OSBoundedPtrFwd.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2019 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_FWD_H
+#define XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_FWD_H
+
+#if !TAPI
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/IOLib.h>
+#include <DriverKit/bounded_ptr_fwd.h>
+#else
+#include <kern/debug.h>
+#include <libkern/c++/bounded_ptr_fwd.h>
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+
+namespace os_detail {
+struct panic_trapping_policy;
+}
+
+template <typename T>
+using OSBoundedPtr = libkern::bounded_ptr<T, os_detail::panic_trapping_policy>;
+
+#endif /* !TAPI */
+
+#endif /* !XNU_LIBKERN_LIBKERN_CXX_OS_BOUNDED_PTR_FWD_H */
diff --git a/iokit/DriverKit/bounded_array.h b/iokit/DriverKit/bounded_array.h
new file mode 100644
index 00000000..57e10274
--- /dev/null
+++ b/iokit/DriverKit/bounded_array.h
@@ -0,0 +1,116 @@
+//
+// Copyright (c) 2019 Apple, Inc. All rights reserved.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+//
+// This file contains Original Code and/or Modifications of Original Code
+// as defined in and that are subject to the Apple Public Source License
+// Version 2.0 (the 'License'). You may not use this file except in
+// compliance with the License. The rights granted to you under the License
+// may not be used to create, or enable the creation or redistribution of,
+// unlawful or unlicensed copies of an Apple operating system, or to
+// circumvent, violate, or enable the circumvention or violation of, any
+// terms of an Apple operating system software license agreement.
+//
+// Please obtain a copy of the License at
+// http://www.opensource.apple.com/apsl/ and read it before using this file.
+//
+// The Original Code and all software distributed under the License are
+// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+// Please see the License for the specific language governing rights and
+// limitations under the License.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+//
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_H
+#define XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_H
+
+#if !TAPI
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/bounded_ptr.h>
+#else
+#include <libkern/c++/bounded_ptr.h>
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+#include <stddef.h>
+#include <os/base.h>
+
+namespace libkern {
+// `bounded_array` is a simple abstraction for a C-style array.
+//
+// Unlike C-style arrays, however, it ensures that the array is not accessed
+// outside of its bounds. Furthermore, the iterators of the `bounded_array`
+// are `bounded_ptr`, which track the range they're allowed to access.
+//
+// TODO:
+// - Should we provide deep comparison operators?
+// - Document individual methods
+template <typename T, size_t N, typename TrappingPolicy>
+struct bounded_array {
+	// DO NOT USE THIS MEMBER DIRECTLY OR WE WILL BREAK YOUR CODE IN THE FUTURE.
+	// THIS HAS TO BE PUBLIC FOR THIS TYPE TO SUPPORT AGGREGATE-INITIALIZATION.
+	T data_[N];
+
+	using iterator = bounded_ptr<T, TrappingPolicy>;
+	using const_iterator = bounded_ptr<T const, TrappingPolicy>;
+
+	OS_ALWAYS_INLINE iterator
+	begin() noexcept
+	{
+		return iterator(data_, data_, data_ + N);
+	}
+	OS_ALWAYS_INLINE const_iterator
+	begin() const noexcept
+	{
+		return const_iterator(data_, data_, data_ + N);
+	}
+	iterator
+	end() noexcept
+	{
+		return iterator(data_ + N, data_, data_ + N);
+	}
+	const_iterator
+	end() const noexcept
+	{
+		return const_iterator(data_ + N, data_, data_ + N);
+	}
+	constexpr size_t
+	size() const noexcept
+	{
+		return N;
+	}
+	constexpr size_t
+	length() const noexcept
+	{
+		return N;
+	}
+	constexpr T*
+	data() noexcept
+	{
+		return data_;
+	}
+	constexpr T const*
+	data() const noexcept
+	{
+		return data_;
+	}
+	OS_ALWAYS_INLINE T&
+	operator[](ptrdiff_t n)
+	{
+		return begin()[n];
+	}
+	OS_ALWAYS_INLINE T const&
+	operator[](ptrdiff_t n) const
+	{
+		return begin()[n];
+	}
+};
+} // end namespace libkern
+
+#endif /* !TAPI */
+
+#endif // !XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_H
diff --git a/iokit/DriverKit/bounded_array_ref.h b/iokit/DriverKit/bounded_array_ref.h
new file mode 100644
index 00000000..fe060a6d
--- /dev/null
+++ b/iokit/DriverKit/bounded_array_ref.h
@@ -0,0 +1,302 @@
+//
+// Copyright (c) 2019 Apple, Inc. All rights reserved.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+//
+// This file contains Original Code and/or Modifications of Original Code
+// as defined in and that are subject to the Apple Public Source License
+// Version 2.0 (the 'License'). You may not use this file except in
+// compliance with the License. The rights granted to you under the License
+// may not be used to create, or enable the creation or redistribution of,
+// unlawful or unlicensed copies of an Apple operating system, or to
+// circumvent, violate, or enable the circumvention or violation of, any
+// terms of an Apple operating system software license agreement.
+//
+// Please obtain a copy of the License at
+// http://www.opensource.apple.com/apsl/ and read it before using this file.
+//
+// The Original Code and all software distributed under the License are
+// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+// Please see the License for the specific language governing rights and
+// limitations under the License.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+//
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_REF_H
+#define XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_REF_H
+
+#if !TAPI
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/bounded_array.h>
+#include <DriverKit/bounded_ptr.h>
+#else
+#include <libkern/c++/bounded_array.h>
+#include <libkern/c++/bounded_ptr.h>
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+
+#include <stddef.h>
+#include <os/base.h>
+
+namespace libkern {
+namespace bar_detail {
+using nullptr_t = decltype(nullptr);
+}
+
+// Represents a reference to a sequence of 0 or more elements consecutively in
+// memory, i.e. a start pointer and a length.
+//
+// When elements of the sequence are accessed, `bounded_array_ref` ensures
+// that those elements are in the bounds of the sequence (which are provided
+// when the `bounded_array_ref` is constructed).
+//
+// This class does not own the underlying data. It is expected to be used in
+// situations where the data resides in some other buffer, whose lifetime
+// extends past that of the `bounded_array_ref`. For this reason, storing a
+// `bounded_array_ref` adds the risk of a dangling pointer if the lifetime of
+// the `bounded_array_ref` extends past that of the underlying data.
+//
+// `bounded_array_ref` is trivially copyable and it should be passed by value.
+template <typename T, typename TrappingPolicy>
+struct bounded_array_ref {
+	// Creates an empty `bounded_array_ref`.
+	//
+	// An empty `bounded_array_ref` does not reference anything, so its
+	// `data()` is null and its `size()` is 0.
+	explicit constexpr bounded_array_ref() noexcept : data_(nullptr), size_(0)
+	{
+	}
+
+	// Creates a `bounded_array_ref` from a bounded pointer and a size.
+	//
+	// The resulting `bounded_array_ref` starts at the location where the
+	// pointer points, and has the given number of elements. All the elements
+	// must be in the bounds of the `bounded_ptr`, otherwise this constructor
+	// will trap.
+	explicit constexpr bounded_array_ref(bounded_ptr<T, TrappingPolicy> data, size_t n)
+		: data_(data.unsafe_discard_bounds()), size_(static_cast<uint32_t>(n))
+	{
+		if (n != 0) {
+			data[n - 1]; // make sure the bounds are valid
+			// TODO: find a better way to do that
+		}
+		if (__improbable(n > UINT32_MAX)) {
+			TrappingPolicy::trap("bounded_array_ref: Can't construct from a size greater than UINT32_MAX");
+		}
+	}
+
+	// Creates a `bounded_array_ref` from a raw pointer and a size.
+	//
+	// The resulting `bounded_array_ref` starts at the location where the
+	// pointer points, and has the given number of elements. This constructor
+	// trusts that `n` elements are reachable from the given pointer.
+	explicit constexpr bounded_array_ref(T* data, size_t n) : data_(data), size_(static_cast<uint32_t>(n))
+	{
+		if (__improbable(n > UINT32_MAX)) {
+			TrappingPolicy::trap("bounded_array_ref: Can't construct from a size greater than UINT32_MAX");
+		}
+	}
+
+	// Creates a `bounded_array_ref` from a `[first, last)` half-open range.
+	//
+	// The resulting `bounded_array_ref` starts at the location pointed-to by
+	// `first`, and contains `last - first` elements. The `[first, last)`
+	// half-open range must be a valid range, i.e. it must be the case that
+	// `first <= last`, otherwise the constructor traps.
+	explicit constexpr bounded_array_ref(T* first, T* last) : data_(first), size_(static_cast<uint32_t>(last - first))
+	{
+		if (__improbable(first > last)) {
+			TrappingPolicy::trap("bounded_array_ref: The [first, last) constructor requires a valid range.");
+		}
+		if (__improbable(last - first > UINT32_MAX)) {
+			TrappingPolicy::trap("bounded_array_ref: Can't construct from a size greater than UINT32_MAX");
+		}
+	}
+
+	// Creates a `bounded_array_ref` from a `bounded_array`.
+	//
+	// The resulting `bounded_array_ref` starts at the first element of the
+	// `bounded_array`, and has the number of elements in the `bounded_array`.
+	template <size_t N>
+	constexpr bounded_array_ref(bounded_array<T, N, TrappingPolicy>& data) : data_(data.data()), size_(static_cast<uint32_t>(data.size()))
+	{
+		if (__improbable(data.size() > UINT32_MAX)) {
+			TrappingPolicy::trap("bounded_array_ref: Can't construct from a size greater than UINT32_MAX");
+		}
+	}
+
+	// Creates a `bounded_array_ref` from a C-style array.
+	//
+	// The resulting `bounded_array_ref` starts at the first element of the
+	// C-style array, and has the number of elements in that array.
+	template <size_t N>
+	constexpr bounded_array_ref(T (&array)[N]) : data_(array), size_(static_cast<uint32_t>(N))
+	{
+		if (__improbable(N > UINT32_MAX)) {
+			TrappingPolicy::trap("bounded_array_ref: Can't construct from a size greater than UINT32_MAX");
+		}
+	}
+
+	constexpr
+	bounded_array_ref(bounded_array_ref const&) = default;
+	constexpr
+	bounded_array_ref(bounded_array_ref&& other) noexcept = default;
+
+	constexpr bounded_array_ref& operator=(bounded_array_ref const&) = default;
+	constexpr bounded_array_ref& operator=(bounded_array_ref&& other) = default;
+	~bounded_array_ref() = default;
+
+	// Returns whether the `bounded_array_ref` points to a sequence or not.
+	//
+	// Note that pointing to a sequence at all is different from pointing to
+	// a valid sequence, or having a size of 0. If a `bounded_array_ref`
+	// points to a sequence (regardless of whether it is valid or whether
+	// the size of that sequence is 0), this operator will return true.
+	explicit
+	operator bool() const noexcept
+	{
+		return data_ != nullptr;
+	}
+
+	using iterator = bounded_ptr<T, TrappingPolicy>;
+
+	// The following methods allow obtaining iterators (i.e. cursors) to
+	// objects inside a `bounded_array_ref`.
+	//
+	// The iterators of a `bounded_array_ref` are `bounded_ptr`s, which know
+	// the bounds of the sequence and will trap when dereferenced outside
+	// of those bounds.
+	//
+	// `begin()` returns an iterator to the first element in the range, and
+	// `end()` returns an iterator to one-past-the-last element in the range.
+	// The `end()` iterator can't be dereferenced, since it is out of bounds.
+	//
+	// If the `bounded_array_ref` is empty, these methods will return null
+	// `bounded_ptr`s, which can be checked for equality but can't be
+	// dereferenced.
+	OS_ALWAYS_INLINE iterator
+	begin() const noexcept
+	{
+		return iterator(data_, data_, data_ + size_);
+	}
+	iterator
+	end() const noexcept
+	{
+		return iterator(data_ + size_, data_, data_ + size_);
+	}
+
+	// Returns the number of elements in the range referenced by the
+	// `bounded_array_ref`.
+	//
+	// This method returns `0` if the `bounded_array_ref` is null, since
+	// such an array ref behaves the same as an empty range.
+	constexpr size_t
+	size() const noexcept
+	{
+		return size_;
+	}
+
+	// This has the same behavior as size(), but is intended to avoid confusion
+	// about whether it is returning an array count or size in bytes.
+	constexpr size_t
+	length() const noexcept
+	{
+		return size_;
+	}
+
+	// Returns a non-owning pointer to the underlying memory referenced by a
+	// `bounded_array_ref`.
+	//
+	// This method can be called even if the `bounded_array_ref` is null, in
+	// which case the returned pointer will be null.
+	constexpr T*
+	data() const noexcept
+	{
+		return data_;
+	}
+
+	// Access the n-th element of a `bounded_array_ref`.
+	//
+	// If `n` is out of the bounds of the sequence, this operation will
+	// trap. If the array ref is null, this operation will trap too.
+	//
+	// Design note:
+	// We voluntarily use a signed type to represent the index even though a
+	// negative index will always cause a trap. If we used an unsigned type,
+	// we could get an implicit conversion from signed to unsigned, which
+	// could silently wrap around. We think trapping early is more likely
+	// to be helpful in this situation.
+	OS_ALWAYS_INLINE T&
+	operator[](ptrdiff_t n) const
+	{
+		return begin()[n];
+	}
+
+	// Chop off the first `n` elements of the array, and keep `m` elements
+	// in the array.
+	//
+	// The resulting range can be described by `[beg + n, beg + n + m)`, where
+	// `beg` is the `begin()` of the range being sliced. This operation traps
+	// if `n + m` is larger than the number of elements in the array.
+	//
+	// Since `bounded_array_ref` checks (or assumes) that the range it is
+	// given on construction is within bounds and `slice()` checks that the
+	// produced slice is within the original range, it is impossible to create
+	// a `bounded_array_ref` that isn't a subset of a valid range using this
+	// function.
+	bounded_array_ref<T, TrappingPolicy>
+	slice(size_t n, size_t m) const
+	{
+		uint32_t total;
+		if (__improbable(os_add_overflow(n, m, &total))) {
+			TrappingPolicy::trap("bounded_array_ref: n + m is larger than the size of any bounded_array_ref");
+		}
+		if (__improbable(total > size())) {
+			TrappingPolicy::trap("bounded_array_ref: invalid slice provided, the indices are of bounds for the bounded_array_ref");
+		}
+		return bounded_array_ref(data_ + n, m);
+	}
+
+private:
+	T* data_;
+	uint32_t size_;
+};
+
+// The comparison functions against `nullptr` all return whether the
+// `bounded_array_ref` references a sequence or not.
+template <typename T, typename P>
+bool
+operator==(bounded_array_ref<T, P> const& x, bar_detail::nullptr_t)
+{
+	return !static_cast<bool>(x);
+}
+
+template <typename T, typename P>
+bool
+operator!=(bounded_array_ref<T, P> const& x, bar_detail::nullptr_t)
+{
+	return !(x == nullptr);
+}
+
+template <typename T, typename P>
+bool
+operator==(bar_detail::nullptr_t, bounded_array_ref<T, P> const& x)
+{
+	return x == nullptr;
+}
+
+template <typename T, typename P>
+bool
+operator!=(bar_detail::nullptr_t, bounded_array_ref<T, P> const& x)
+{
+	return x != nullptr;
+}
+} // end namespace libkern
+
+#endif /* !TAPI */
+
+#endif // !XNU_LIBKERN_LIBKERN_CXX_BOUNDED_ARRAY_REF_H
diff --git a/iokit/DriverKit/bounded_ptr.h b/iokit/DriverKit/bounded_ptr.h
new file mode 100644
index 00000000..4c7de13f
--- /dev/null
+++ b/iokit/DriverKit/bounded_ptr.h
@@ -0,0 +1,710 @@
+//
+// Copyright (c) 2019 Apple, Inc. All rights reserved.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+//
+// This file contains Original Code and/or Modifications of Original Code
+// as defined in and that are subject to the Apple Public Source License
+// Version 2.0 (the 'License'). You may not use this file except in
+// compliance with the License. The rights granted to you under the License
+// may not be used to create, or enable the creation or redistribution of,
+// unlawful or unlicensed copies of an Apple operating system, or to
+// circumvent, violate, or enable the circumvention or violation of, any
+// terms of an Apple operating system software license agreement.
+//
+// Please obtain a copy of the License at
+// http://www.opensource.apple.com/apsl/ and read it before using this file.
+//
+// The Original Code and all software distributed under the License are
+// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+// Please see the License for the specific language governing rights and
+// limitations under the License.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+//
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_H
+#define XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_H
+
+#if !TAPI
+
+#include <stddef.h>
+#include <stdint.h>
+#include <os/overflow.h>
+#include <os/base.h>
+
+#if !defined(__improbable)
+#   define __improbable(...) __builtin_expect((__VA_ARGS__), 0)
+#endif
+
+namespace libkern {
+namespace detail {
+// Reimplementation of things in <type_traits> because we don't seem
+// to have the right to rely on the C++ Standard Library (based on
+// attempts to compile IOHIDFamily).
+// TODO: Do we really need to re-implement this here?
+template <typename ...> using void_t = void;
+template <typename T> T && declval() noexcept;
+using nullptr_t = decltype(nullptr);
+template <bool Cond, typename T = void> struct enable_if;
+template <typename T> struct enable_if<true, T> { using type = T; };
+template <bool Cond, typename T = void> using enable_if_t = typename enable_if<Cond, T>::type;
+template <typename T1, typename T2>
+constexpr bool is_convertible_v = __is_convertible_to(T1, T2);
+
+template <typename T> inline constexpr bool is_void_v = false;
+template <> inline constexpr bool is_void_v<void> = true;
+template <> inline constexpr bool is_void_v<void const> = true;
+
+template <typename T, typename U> struct copy_const { using type = U; };
+template <typename T, typename U> struct copy_const<T const, U> { using type = U const; };
+template <typename T, typename U> using copy_const_t = typename copy_const<T, U>::type;
+
+template <typename T, typename U> struct copy_cv { using type = U; };
+template <typename T, typename U> struct copy_cv<T const, U> { using type = U const; };
+template <typename T, typename U> struct copy_cv<T volatile, U> { using type = U volatile; };
+template <typename T, typename U> struct copy_cv<T const volatile, U> { using type = U const volatile; };
+template <typename T, typename U> using copy_cv_t = typename copy_cv<T, U>::type;
+
+template <typename T, typename U>
+using WhenComparable = void_t<
+	decltype(declval<T>() == declval<U>()),
+	decltype(declval<T>() != declval<U>())
+	>;
+
+template <typename T, typename U>
+using WhenOrderable = void_t <
+    decltype(declval<T>() < declval<U>()),
+decltype(declval<T>() > declval<U>()),
+decltype(declval<T>() >= declval<U>()),
+decltype(declval<T>() <= declval<U>())
+>;
+
+// Pretend that sizeof(void) is 1, otherwise the in-bounds check doesn't
+// make sense for `bounded_ptr<void>`.
+template <typename T> constexpr size_t sizeof_v = sizeof(T);
+template <>           inline constexpr size_t sizeof_v<void> = 1;
+template <>           inline constexpr size_t sizeof_v<void const> = 1;
+template <>           inline constexpr size_t sizeof_v<void volatile> = 1;
+template <>           inline constexpr size_t sizeof_v<void const volatile> = 1;
+} // end namespace detail
+
+// Non-owning pointer to an object (or a range of objects) of type `T`
+// that validates that the address is within some specified bounds on
+// dereference-like operations.
+//
+// Conceptually, a `bounded_ptr` points within a range of memory `[begin, end)`.
+// If accessing any part of the result of dereferencing the pointer would
+// lead to an access outside of the `[begin, end)` range, the pointer is
+// said to be out-of-bounds. Due to representational constraints, the range
+// of in-bounds memory must be no larger than 4GB.
+//
+// Dereference-like operations (dereference, subscript, pointer member access)
+// validate that the pointer is not out-of-bounds. If an out-of-bounds pointer
+// is dereferenced, the `TrappingPolicy` is called as
+// `TrappingPolicy::trap(some-message)`, and the operation is said to "trap".
+// This terminology is used below to describe the behavior of the `TrappingPolicy`.
+//
+// Pointer arithmetic is allowed (and the bounds are not validated), so it is
+// entirely possible to make a `bounded_ptr` point outside of its range.
+// However, overflow checking is performed on arithmetic operations, and
+// any operation resulting in an overflow will also "trap".
+//
+// The behavior of the `TrappingPolicy` can be customized as desired, however
+// a trap should never return, causing the current `bounded_ptr` operation to
+// be aborted. This is important since the trap could signify an integer
+// overflow, a null-pointer dereference or something else that would lead to
+// undefined behavior (UB) if `TrappingPolicy::trap` were to return.
+//
+// Creation of `bounded_ptr`s
+// ==========================
+// `bounded_ptr` provides a single constructor allowing the bounds of the
+// pointer to be specified. When integrating `bounded_ptr` into an existing
+// code base, it is recommended to use `bounded_ptr` as an iterator obtained
+// from other container-like abstractions, instead of manually using the
+// constructor that allows specifying a range. Specifying the range manually
+// on construction is error-prone, and `bounded_ptr` can't help reduce
+// out-of-bounds accesses if the bounds are specified incorrectly.
+//
+// Furthermore, it is a design choice to not provide a constructor that uses
+// relative offsets from the pointer itself to determine the range, because
+// such a constructor is deemed more confusing than helpful. For example, is
+// the offset a number of bytes or a number of objects? Is the offset inclusive
+// or exclusive? Instead, factory functions should be used to create `bounded_ptr`s.
+//
+// Remark on const-ness
+// ====================
+// Like for raw pointers, the const-ness of a `bounded_ptr` has no bearing on
+// whether the pointee is const. Hence, it is possible to obtain a non-const
+// reference to an object from a const `bounded_ptr`. To encode a
+// pointer-to-const, simply create a `bounded_ptr<T const>`.
+template <typename T, typename TrappingPolicy>
+struct __attribute__((trivial_abi)) bounded_ptr {
+private:
+	using CharType = detail::copy_cv_t<T, char>;
+
+public:
+	// Creates a null `bounded_ptr`.
+	//
+	// A null `bounded_ptr` does not point to any object and is conceptually
+	// out of bounds, so dereferencing it will trap. "Observing" operations
+	// like comparison and check-for-null, along with assignment, are valid
+	// operations on a null `bounded_ptr`.
+	OS_ALWAYS_INLINE constexpr
+	bounded_ptr(detail::nullptr_t)
+		: base_(nullptr), count_(0), offset_(0)
+	{
+	}
+
+	OS_ALWAYS_INLINE constexpr
+	explicit
+	bounded_ptr()
+		: bounded_ptr(nullptr)
+	{
+	}
+
+	// Creates a `bounded_ptr` pointing to the given object, and whose bounds
+	// are described by the provided `[begin, end)` range.
+	//
+	// This constructor does not check whether the constructed pointer is
+	// within its bounds. However, it does check that the provided `[begin, end)`
+	// range is a valid range (that is, `begin <= end`).
+	//
+	// Furthermore, the number of bytes in the range of in-bounds memory must be
+	// representable by a uint32_t, which means that there can be no more than
+	// 2^32 bytes (i.e. 4GB) in that range. Otherwise, the constructor will trap.
+	OS_ALWAYS_INLINE explicit
+	bounded_ptr(T* pointer, T const* begin, T const* end)
+	{
+		base_ = reinterpret_cast<CharType*>(const_cast<T*>(begin));
+
+		// Store (end - begin) into count_, making sure we don't overflow
+		if (__improbable(os_sub_overflow(reinterpret_cast<uintptr_t>(end),
+		    reinterpret_cast<uintptr_t>(begin),
+		    &count_))) {
+			TrappingPolicy::trap("The range of valid memory is too large to be represented "
+			    "by this type, or [begin, end) is not a well-formed range");
+		}
+
+		// Store (pointer - begin) into offset_, making sure we don't overflow.
+		// Note that offset_ can be negative if `pointer` is outside of the
+		// range delimited by [begin, end), which can be valid if it represents
+		// e.g. a subrange of an array.
+		if (__improbable(os_sub_overflow(reinterpret_cast<uintptr_t>(pointer),
+		    reinterpret_cast<uintptr_t>(begin),
+		    &offset_))) {
+			TrappingPolicy::trap("The offset of the pointer inside its valid memory "
+			    "range can't be represented using int32_t");
+		}
+	}
+
+	// Creates a `bounded_ptr` to a type `T` from a `bounded_ptr` to a type `U`.
+	//
+	// This converting constructor is enabled whenever `U*` is implicitly
+	// convertible to `T*`. This allows the usual implicit conversions
+	// between base-and-derived types, and also from any type `U*` to a
+	// `void*`. If other casts (like between unrelated pointer types) are
+	// desired, `libkern::reinterpret_pointer_cast` can be used instead.
+	//
+	// The bounds on the resulting `bounded_ptr` are inherited from the
+	// original `bounded_ptr`.
+	template <typename U, typename Policy, typename = detail::enable_if_t<detail::is_convertible_v<U*, T*> > >
+	OS_ALWAYS_INLINE
+	bounded_ptr(bounded_ptr<U, Policy> const & other)
+		: base_(other.base_)
+		, count_(other.count_)
+		, offset_(static_cast<int32_t>(reinterpret_cast<CharType*>(static_cast<T*>(other.get_ptr_())) - other.base_))
+	{
+	}
+
+	// Assigns a `bounded_ptr` to a type `U` to a `bounded_ptr` to a type `T`,
+	// as long as `U*` is convertible to `T*`.
+	//
+	// This is a rebinding operation, like assignment between raw pointers,
+	// and the destination `bounded_ptr` will inherit the bounds of the
+	// source `bounded_ptr`.
+	template <typename U, typename Policy, typename = detail::enable_if_t<detail::is_convertible_v<U*, T*> > >
+	OS_ALWAYS_INLINE bounded_ptr&
+	operator=(bounded_ptr<U, Policy> const& other)
+	{
+		base_ = other.base_;
+		count_ = other.count_;
+		offset_ = static_cast<int32_t>(reinterpret_cast<CharType*>(static_cast<T*>(other.get_ptr_())) - other.base_);
+		return *this;
+	}
+
+	// Sets a `bounded_ptr` to null.
+	//
+	// This is effectively equivalent to assigning a default-constructed
+	// `bounded_ptr` to the target. As a result, the original bounds of
+	// the `bounded_ptr` are discarded, and the resulting `bounded_ptr`
+	// is both out-of-bounds and also has no bounds assigned to it (like
+	// a default-constructed `bounded_ptr`).
+	OS_ALWAYS_INLINE bounded_ptr&
+	operator=(detail::nullptr_t)
+	{
+		*this = bounded_ptr();
+		return *this;
+	}
+
+	// Returns a reference to the object pointed-to by the `bounded_ptr`.
+	//
+	// Traps if the pointer is pointing outside of its bounds.
+	//
+	// Also note that this function will trap when dereferencing a null
+	// `bounded_ptr`, unless the bounds of the pointer have been set and
+	// include address 0, in which case there's effectively nothing to
+	// diagnose.
+	template <typename T_ = T> // delay instantiation to avoid forming invalid ref for bounded_ptr<void>
+	OS_ALWAYS_INLINE T_&
+	operator*() const
+	{
+		if (__improbable(!in_bounds_())) {
+			TrappingPolicy::trap("bounded_ptr<T>::operator*: Dereferencing this pointer "
+			    "would access memory outside of the bounds set originally");
+		}
+		return *get_ptr_();
+	}
+
+	OS_ALWAYS_INLINE T*
+	operator->() const
+	{
+		if (__improbable(!in_bounds_())) {
+			TrappingPolicy::trap("bounded_ptr<T>::operator->: Accessing a member through this pointer "
+			    "would access memory outside of the bounds set originally");
+		}
+		return get_ptr_();
+	}
+
+	// Provides access to the n-th element past the given pointer.
+	//
+	// The `bounded_ptr` validates whether the provided index is within the
+	// bounds of the `bounded_ptr`. Like for raw pointers, a negative index
+	// may be passed, in which case the pointer is accessed at a negative
+	// offset (which must still be in bounds).
+	template <typename T_ = T> // delay instantiation to avoid forming invalid ref for bounded_ptr<void>
+	OS_ALWAYS_INLINE T_&
+	operator[](ptrdiff_t n) const
+	{
+		return *(*this + n);
+	}
+
+	// Converts a `bounded_ptr` to a raw pointer, after checking it is within
+	// its bounds.
+	//
+	// The primary intended usage of this function is to aid bridging between
+	// code that uses `bounded_ptr`s and code that does not.
+	OS_ALWAYS_INLINE T*
+	discard_bounds() const
+	{
+		if (__improbable(!in_bounds_())) {
+			TrappingPolicy::trap("bounded_ptr<T>::discard_bounds: Discarding the bounds on "
+			    "this pointer would lose the fact that it is outside of the "
+			    "bounds set originally");
+		}
+		return get_ptr_();
+	}
+
+	// Converts a `bounded_ptr` to a raw pointer, without checking whether the
+	// pointer is within its bounds.
+	//
+	// Like `discard_bounds()`, the primary intended usage of this function
+	// is to aid bridging between code that uses `bounded_ptr`s and code that
+	// does not. However, unlike `discard_bounds()`, this function does not
+	// validate that the returned pointer is in bounds. This functionality is
+	// necessary when the pointer represents something that can't be
+	// dereferenced (hence it's OK for it to be out-of-bounds), but that
+	// is still useful for other purposes like comparing against other
+	// pointers. An example of that is the `end` pointer in a half-open
+	// interval `[begin, end)`, where the `end` pointer is out-of-bounds and
+	// can't be dereferenced, yet it's still useful to delimit the range.
+	OS_ALWAYS_INLINE T*
+	unsafe_discard_bounds() const
+	{
+		return get_ptr_();
+	}
+
+	// Implicit conversion to bool, returning whether the pointer is null.
+	//
+	// This operation does not perform any validation of the bounds.
+	OS_ALWAYS_INLINE explicit
+	operator bool() const
+	{
+		return get_ptr_() != nullptr;
+	}
+
+	// Increment/decrement a `bounded_ptr`.
+	//
+	// Like for other arithmetic operations, this does not check whether the
+	// increment or decrement operation results in an out-of-bounds pointer.
+	OS_ALWAYS_INLINE bounded_ptr&
+	operator++()
+	{
+		*this += 1;
+		return *this;
+	}
+	OS_ALWAYS_INLINE bounded_ptr
+	operator++(int)
+	{
+		bounded_ptr old = *this;
+		++*this;
+		return old;
+	}
+	OS_ALWAYS_INLINE bounded_ptr&
+	operator--()
+	{
+		*this -= 1;
+		return *this;
+	}
+	OS_ALWAYS_INLINE bounded_ptr
+	operator--(int)
+	{
+		bounded_ptr old = *this;
+		--*this;
+		return old;
+	}
+
+	// Increment or decrement a `bounded_ptr` by a given offset.
+	//
+	// This is equivalent to adding the given offset to the underlying raw
+	// pointer. In particular, the bounds of the `bounded_ptr` are left
+	// untouched by this operation. Furthermore, like for raw pointers, it
+	// is possible to provide a negative offset, which will have the effect
+	// of decrementing the `bounded_ptr` instead of incrementing it.
+	//
+	// Also note that the offset is NOT a number of bytes -- just like for
+	// raw pointers, it is a number of "positions" to move the pointer from,
+	// which essentially means `n * sizeof(T)` bytes. Again, this works exactly
+	// the same as a raw pointer to an object of type `T`.
+	//
+	// Like other arithmetic operations, this does not check whether the
+	// increment or decrement operation results in an out-of-bounds pointer.
+	// However, this does check whether the arithmetic operation would result
+	// in an overflow, in which case the operation will trap.
+	template <typename T_ = T>
+	OS_ALWAYS_INLINE bounded_ptr&
+	operator+=(ptrdiff_t n)
+	{
+		static_assert(!detail::is_void_v<T_>, "Arithmetic on bounded_ptr<void> is not allowed.");
+
+		ptrdiff_t bytes;
+		if (__improbable(os_mul_overflow(n, sizeof(T), &bytes))) {
+			TrappingPolicy::trap(
+				"bounded_ptr<T>::operator+=(n): Calculating the number of bytes to "
+				"add to the offset (n * sizeof(T)) would trigger an overflow");
+		}
+		if (__improbable(os_add_overflow(offset_, bytes, &offset_))) {
+			TrappingPolicy::trap(
+				"bounded_ptr<T>::operator+=(n): Adding the specified number of bytes "
+				"to the offset representing the current position would overflow.");
+		}
+		return *this;
+	}
+
+	template <typename T_ = T>
+	OS_ALWAYS_INLINE bounded_ptr&
+	operator-=(ptrdiff_t n)
+	{
+		static_assert(!detail::is_void_v<T_>, "Arithmetic on bounded_ptr<void> is not allowed.");
+
+		ptrdiff_t bytes;
+		if (__improbable(os_mul_overflow(n, sizeof(T), &bytes))) {
+			TrappingPolicy::trap(
+				"bounded_ptr<T>::operator-=(n): Calculating the number of bytes to "
+				"subtract from the offset (n * sizeof(T)) would trigger an overflow");
+		}
+		if (__improbable(os_sub_overflow(offset_, bytes, &offset_))) {
+			TrappingPolicy::trap(
+				"bounded_ptr<T>::operator-=(n): Subtracting the specified number of bytes "
+				"from the offset representing the current position would overflow.");
+		}
+		return *this;
+	}
+
+	friend OS_ALWAYS_INLINE bounded_ptr
+	operator+(bounded_ptr p, ptrdiff_t n)
+	{
+		p += n;
+		return p;
+	}
+	friend OS_ALWAYS_INLINE bounded_ptr
+	operator+(ptrdiff_t n, bounded_ptr p)
+	{
+		p += n;
+		return p;
+	}
+	friend OS_ALWAYS_INLINE bounded_ptr
+	operator-(bounded_ptr p, ptrdiff_t n)
+	{
+		p -= n;
+		return p;
+	}
+
+	// Returns the difference between two `bounded_ptr`s.
+	//
+	// This is semantically equivalent to subtracting the two underlying
+	// pointers. The bounds of the pointers are not validated by this
+	// operation.
+	friend OS_ALWAYS_INLINE ptrdiff_t
+	operator-(bounded_ptr const& a, bounded_ptr const& b)
+	{
+		return a.get_ptr_() - b.get_ptr_();
+	}
+
+	friend OS_ALWAYS_INLINE ptrdiff_t
+	operator-(bounded_ptr const& a, T const* b)
+	{
+		return a.get_ptr_() - b;
+	}
+
+	friend OS_ALWAYS_INLINE ptrdiff_t
+	operator-(T const* a, bounded_ptr const& b)
+	{
+		return a - b.get_ptr_();
+	}
+
+private:
+	OS_ALWAYS_INLINE bool
+	in_bounds_() const
+	{
+		static_assert(detail::sizeof_v<T> <= UINT32_MAX - INT32_MAX,
+		    "The type pointed-to by bounded_ptr is too large, which would defeat "
+		    "our optimization to check for inboundedness using arithmetic on unsigned");
+		return offset_ >= 0 && static_cast<uint32_t>(offset_) + static_cast<uint32_t>(detail::sizeof_v<T>) <= count_;
+	}
+
+	OS_ALWAYS_INLINE T*
+	get_ptr_() const
+	{
+		// Compute `base_ + offset_`, catching overflows.
+		uintptr_t ptr;
+		if (__improbable(os_add_overflow(reinterpret_cast<uintptr_t>(base_), offset_, &ptr))) {
+			TrappingPolicy::trap("This bounded_ptr is pointing to memory outside of what can "
+			    "be represented by a native pointer.");
+		}
+		return reinterpret_cast<T*>(ptr);
+	}
+
+	template <typename T_, typename U, typename Policy>
+	friend bounded_ptr<T_, Policy> reinterpret_pointer_cast(bounded_ptr<U, Policy> const&) noexcept;
+
+	template <typename U, typename P> friend struct bounded_ptr; // for cross-type operations and conversions
+
+	CharType* base_; // pointer to the beginning of the valid address range
+	uint32_t count_; // number of bytes considered in-bounds (non-negative)
+	int32_t offset_; // current offset into the range, in bytes
+};
+
+// Returns whether two `bounded_ptr`s point to the same object.
+//
+// This comparison is semantically equivalent to comparing the underlying
+// raw pointers. In particular, it doesn't validate the bounds of either
+// `bounded_ptr`, nor does it compare whether the two `bounded_ptr`s have
+// the same bounds.
+//
+// This comparison is enabled between `bounded_ptr`s whenever the two
+// corresponding raw pointer types are comparable. Comparison between a
+// raw pointer and a `bounded_ptr` is also allowed, so long as the
+// two corresponding raw pointer types are comparable.
+template <typename T, typename P1, typename U, typename P2, typename = detail::WhenComparable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator==(bounded_ptr<T, P1> const& a, bounded_ptr<U, P2> const& b)
+{
+	return a.unsafe_discard_bounds() == b.unsafe_discard_bounds();
+}
+
+template <typename T, typename P1, typename U, typename P2, typename = detail::WhenComparable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator!=(bounded_ptr<T, P1> const& a, bounded_ptr<U, P2> const& b)
+{
+	return !(a == b);
+}
+
+template <typename T, typename P, typename U, typename = detail::WhenComparable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator==(bounded_ptr<T, P> const& a, U* b)
+{
+	return a.unsafe_discard_bounds() == b;
+}
+
+template <typename T, typename P, typename U, typename = detail::WhenComparable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator==(U* a, bounded_ptr<T, P> const& b)
+{
+	return a == b.unsafe_discard_bounds();
+}
+
+template <typename T, typename P, typename U, typename = detail::WhenComparable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator!=(bounded_ptr<T, P> const& a, U* b)
+{
+	return !(a == b);
+}
+
+template <typename T, typename P, typename U, typename = detail::WhenComparable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator!=(U* a, bounded_ptr<T, P> const& b)
+{
+	return !(a == b);
+}
+
+template <typename T, typename Policy>
+OS_ALWAYS_INLINE bool
+operator==(detail::nullptr_t, bounded_ptr<T, Policy> const& p)
+{
+	return p.unsafe_discard_bounds() == nullptr;
+}
+
+template <typename T, typename Policy>
+OS_ALWAYS_INLINE bool
+operator!=(detail::nullptr_t, bounded_ptr<T, Policy> const& p)
+{
+	return p.unsafe_discard_bounds() != nullptr;
+}
+
+template <typename T, typename Policy>
+OS_ALWAYS_INLINE bool
+operator==(bounded_ptr<T, Policy> const& p, detail::nullptr_t)
+{
+	return p.unsafe_discard_bounds() == nullptr;
+}
+
+template <typename T, typename Policy>
+OS_ALWAYS_INLINE bool
+operator!=(bounded_ptr<T, Policy> const& p, detail::nullptr_t)
+{
+	return p.unsafe_discard_bounds() != nullptr;
+}
+
+// Returns whether a `bounded_ptr` points to an address that is {less-than,
+// less-than-or-equal-to, greater-than, greater-than-or-equal-to} the address
+// held in another `bounded_ptr`.
+//
+// This doesn't validate the bounds of either `bounded_ptr`, nor does it
+// compare those bounds to determine the ordering result. This ordering is
+// semantically equivalent to ordering the result of calling `get()` on both
+// `bounded_ptr`s.
+//
+// This ordering is enabled between `bounded_ptr`s whenever the two
+// corresponding raw pointer types are orderable. Ordering between a
+// raw pointer and a `bounded_ptr` is also allowed, so long as the
+// two corresponding raw pointer types are orderable.
+//
+
+template <typename T, typename U, typename P1, typename P2, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator<(bounded_ptr<T, P1> const& a, bounded_ptr<U, P2> const& b)
+{
+	return a.unsafe_discard_bounds() < b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P1, typename P2, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator<=(bounded_ptr<T, P1> const& a, bounded_ptr<U, P2> const& b)
+{
+	return a.unsafe_discard_bounds() <= b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P1, typename P2, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator>(bounded_ptr<T, P1> const& a, bounded_ptr<U, P2> const& b)
+{
+	return a.unsafe_discard_bounds() > b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P1, typename P2, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator>=(bounded_ptr<T, P1> const& a, bounded_ptr<U, P2> const& b)
+{
+	return a.unsafe_discard_bounds() >= b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator<(T* a, bounded_ptr<U, P> const& b)
+{
+	return a < b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator<(bounded_ptr<T, P> const& a, U* b)
+{
+	return a.unsafe_discard_bounds() < b;
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator<=(T* a, bounded_ptr<U, P> const& b)
+{
+	return a <= b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator<=(bounded_ptr<T, P> const& a, U* b)
+{
+	return a.unsafe_discard_bounds() <= b;
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator>(T* a, bounded_ptr<U, P> const& b)
+{
+	return a > b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator>(bounded_ptr<T, P> const& a, U* b)
+{
+	return a.unsafe_discard_bounds() > b;
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator>=(T* a, bounded_ptr<U, P> const& b)
+{
+	return a >= b.unsafe_discard_bounds();
+}
+
+template <typename T, typename U, typename P, typename = detail::WhenOrderable<T*, U*> >
+OS_ALWAYS_INLINE bool
+operator>=(bounded_ptr<T, P> const& a, U* b)
+{
+	return a.unsafe_discard_bounds() >= b;
+}
+
+template <typename T, typename U>
+OS_ALWAYS_INLINE T*
+reinterpret_pointer_cast(U* p) noexcept
+{
+	return reinterpret_cast<T*>(p);
+}
+
+// Reinterprets a `bounded_ptr` to a type `T` to a `bounded_ptr` to a type `U`.
+//
+// This is equivalent to `reinterpret_cast`ing the underlying pointer as well
+// as the bounds of the original pointer. Like for a raw `reinterpret_cast`,
+// no offset adjustment is performed (even if needed, e.g. for derived-to-base
+// casts with multiple inheritance). Because this is extremely unsafe, it should
+// be used extremely sparingly.
+template <typename T, typename U, typename Policy>
+OS_ALWAYS_INLINE bounded_ptr<T, Policy>
+reinterpret_pointer_cast(bounded_ptr<U, Policy> const& p) noexcept
+{
+	using CharType = detail::copy_cv_t<T, char>;
+	CharType* new_begin = reinterpret_cast<CharType*>(p.base_);
+	CharType* new_end = new_begin + p.count_;
+	return bounded_ptr<T, Policy>(reinterpret_cast<T*>(p.get_ptr_()),
+	           reinterpret_cast<T const*>(new_begin),
+	           reinterpret_cast<T const*>(new_end));
+}
+} // end namespace libkern
+
+#endif /* !TAPI */
+
+#endif // !XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_H
diff --git a/iokit/DriverKit/bounded_ptr_fwd.h b/iokit/DriverKit/bounded_ptr_fwd.h
new file mode 100644
index 00000000..9613279e
--- /dev/null
+++ b/iokit/DriverKit/bounded_ptr_fwd.h
@@ -0,0 +1,41 @@
+//
+// Copyright (c) 2019 Apple, Inc. All rights reserved.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+//
+// This file contains Original Code and/or Modifications of Original Code
+// as defined in and that are subject to the Apple Public Source License
+// Version 2.0 (the 'License'). You may not use this file except in
+// compliance with the License. The rights granted to you under the License
+// may not be used to create, or enable the creation or redistribution of,
+// unlawful or unlicensed copies of an Apple operating system, or to
+// circumvent, violate, or enable the circumvention or violation of, any
+// terms of an Apple operating system software license agreement.
+//
+// Please obtain a copy of the License at
+// http://www.opensource.apple.com/apsl/ and read it before using this file.
+//
+// The Original Code and all software distributed under the License are
+// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+// Please see the License for the specific language governing rights and
+// limitations under the License.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+//
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_FWD_H
+#define XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_FWD_H
+
+#if !TAPI
+
+namespace libkern {
+template <typename T, typename TrappingPolicy>
+struct __attribute__((trivial_abi)) bounded_ptr;
+} // end namespace libkern
+
+#endif /* !TAPI */
+
+#endif // !XNU_LIBKERN_LIBKERN_CXX_BOUNDED_PTR_FWD_H
diff --git a/iokit/DriverKit/crypto/aes.h b/iokit/DriverKit/crypto/aes.h
new file mode 100644
index 00000000..9e962a87
--- /dev/null
+++ b/iokit/DriverKit/crypto/aes.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2012 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef _AES_H
+#define _AES_H
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+#include <corecrypto/ccmode.h>
+#include <corecrypto/ccn.h>
+
+#define AES_BLOCK_SIZE  16  /* the AES block size in bytes          */
+
+//Unholy HACK: this works because we know the size of the context for every
+//possible corecrypto implementation is less than this.
+#if defined(__ARM_NEON__) && !defined(__arm64__)        // for expanded keys in bit slice format
+#define AES_CBC_CTX_MAX_SIZE (ccn_sizeof_size(sizeof(void *)) + ccn_sizeof_size(AES_BLOCK_SIZE) + ccn_sizeof_size(64*4) + (14-1)*128+32 )
+#else
+#define AES_CBC_CTX_MAX_SIZE (ccn_sizeof_size(sizeof(void *)) + ccn_sizeof_size(AES_BLOCK_SIZE) + ccn_sizeof_size(64*4))
+#endif
+
+typedef struct{
+	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
+} aes_decrypt_ctx;
+
+typedef struct{
+	cccbc_ctx_decl(AES_CBC_CTX_MAX_SIZE, ctx);
+} aes_encrypt_ctx;
+
+typedef struct{
+	aes_decrypt_ctx decrypt;
+	aes_encrypt_ctx encrypt;
+} aes_ctx;
+
+
+/* for compatibility with old apis*/
+#define aes_ret     int
+#define aes_good    0
+#define aes_error  -1
+#define aes_rval    aes_ret
+
+
+
+/* Key lengths in the range 16 <= key_len <= 32 are given in bytes, */
+/* those in the range 128 <= key_len <= 256 are given in bits       */
+
+aes_rval aes_encrypt_key(const unsigned char *key, int key_len, aes_encrypt_ctx cx[1]);
+aes_rval aes_encrypt_key128(const unsigned char *key, aes_encrypt_ctx cx[1]);
+aes_rval aes_encrypt_key256(const unsigned char *key, aes_encrypt_ctx cx[1]);
+
+#if defined (__i386__) || defined (__x86_64__) || defined (__arm64__)
+aes_rval aes_encrypt(const unsigned char *in, unsigned char *out, aes_encrypt_ctx cx[1]);
+#endif
+
+aes_rval aes_encrypt_cbc(const unsigned char *in_blk, const unsigned char *in_iv, unsigned int num_blk,
+    unsigned char *out_blk, aes_encrypt_ctx cx[1]);
+
+
+aes_rval aes_decrypt_key(const unsigned char *key, int key_len, aes_decrypt_ctx cx[1]);
+aes_rval aes_decrypt_key128(const unsigned char *key, aes_decrypt_ctx cx[1]);
+aes_rval aes_decrypt_key256(const unsigned char *key, aes_decrypt_ctx cx[1]);
+
+#if defined (__i386__) || defined (__x86_64__) || defined (__arm64__)
+aes_rval aes_decrypt(const unsigned char *in, unsigned char *out, aes_decrypt_ctx cx[1]);
+#endif
+
+aes_rval aes_decrypt_cbc(const unsigned char *in_blk, const unsigned char *in_iv, unsigned int num_blk,
+    unsigned char *out_blk, aes_decrypt_ctx cx[1]);
+
+aes_rval aes_encrypt_key_gcm(const unsigned char *key, int key_len, ccgcm_ctx *ctx);
+aes_rval aes_encrypt_key_with_iv_gcm(const unsigned char *key, int key_len, const unsigned char *in_iv, ccgcm_ctx *ctx);
+aes_rval aes_encrypt_set_iv_gcm(const unsigned char *in_iv, unsigned int len, ccgcm_ctx *ctx);
+aes_rval aes_encrypt_reset_gcm(ccgcm_ctx *ctx);
+aes_rval aes_encrypt_inc_iv_gcm(unsigned char *out_iv, ccgcm_ctx *ctx);
+aes_rval aes_encrypt_aad_gcm(const unsigned char *aad, unsigned int aad_bytes, ccgcm_ctx *ctx);
+aes_rval aes_encrypt_gcm(const unsigned char *in_blk, unsigned int num_bytes, unsigned char *out_blk, ccgcm_ctx *ctx);
+aes_rval aes_encrypt_finalize_gcm(unsigned char *tag, size_t tag_bytes, ccgcm_ctx *ctx);
+size_t aes_encrypt_get_ctx_size_gcm(void);
+
+aes_rval aes_decrypt_key_gcm(const unsigned char *key, int key_len, ccgcm_ctx *ctx);
+aes_rval aes_decrypt_key_with_iv_gcm(const unsigned char *key, int key_len, const unsigned char *in_iv, ccgcm_ctx *ctx);
+aes_rval aes_decrypt_set_iv_gcm(const unsigned char *in_iv, size_t len, ccgcm_ctx *ctx);
+aes_rval aes_decrypt_reset_gcm(ccgcm_ctx *ctx);
+aes_rval aes_decrypt_inc_iv_gcm(unsigned char *out_iv, ccgcm_ctx *ctx);
+aes_rval aes_decrypt_aad_gcm(const unsigned char *aad, unsigned int aad_bytes, ccgcm_ctx *ctx);
+aes_rval aes_decrypt_gcm(const unsigned char *in_blk, unsigned int num_bytes, unsigned char *out_blk, ccgcm_ctx *ctx);
+aes_rval aes_decrypt_finalize_gcm(unsigned char *tag, size_t tag_bytes, ccgcm_ctx *ctx);
+size_t aes_decrypt_get_ctx_size_gcm(void);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff --git a/iokit/DriverKit/crypto/md5.h b/iokit/DriverKit/crypto/md5.h
new file mode 100644
index 00000000..4ecd947d
--- /dev/null
+++ b/iokit/DriverKit/crypto/md5.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+/*
+ * MD5.H - header file for MD5.C
+ */
+
+/*
+ * Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+ * rights reserved.
+ *
+ * License to copy and use this software is granted provided that it
+ * is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm" in all material mentioning or referencing this software
+ * or this function.
+ *
+ * License is also granted to make and use derivative works provided
+ * that such works are identified as "derived from the RSA Data
+ * Security, Inc. MD5 Message-Digest Algorithm" in all material
+ * mentioning or referencing the derived work.
+ *
+ * RSA Data Security, Inc. makes no representations concerning either
+ * the merchantability of this software or the suitability of this
+ * software for any particular purpose. It is provided "as is"
+ * without express or implied warranty of any kind.
+ *
+ * These notices must be retained in any copies of any part of this
+ * documentation and/or software.
+ */
+
+#ifndef _CRYPTO_MD5_H_
+#define _CRYPTO_MD5_H_
+
+#if KERNEL
+#include <sys/types.h>
+#else /* !KERNEL */
+#include <machine/types.h>
+#endif /* KERNEL */
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+
+#define MD5_DIGEST_LENGTH       16
+
+/* MD5 context. */
+typedef struct {
+	u_int32_t state[4];     /* state (ABCD) */
+	u_int32_t count[2];     /* number of bits, modulo 2^64 (lsb first) */
+	unsigned char buffer[64];       /* input buffer */
+} MD5_CTX;
+
+extern void MD5Init(MD5_CTX *);
+extern void MD5Update(MD5_CTX *, const void *, unsigned int);
+extern void MD5Final(unsigned char [MD5_DIGEST_LENGTH], MD5_CTX *);
+
+__END_DECLS
+
+#endif /* _CRYPTO_MD5_H_ */
diff --git a/iokit/DriverKit/crypto/sha1.h b/iokit/DriverKit/crypto/sha1.h
new file mode 100644
index 00000000..706d10f8
--- /dev/null
+++ b/iokit/DriverKit/crypto/sha1.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+
+#ifndef _CRYPTO_SHA1_H_
+#define _CRYPTO_SHA1_H_
+
+#if KERNEL
+#include <sys/types.h>
+#else /* !KERNEL */
+#include <machine/types.h>
+#endif /* KERNEL */
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#define SHA_DIGEST_LENGTH       20
+#define SHA1_RESULTLEN          SHA_DIGEST_LENGTH
+
+typedef struct sha1_ctxt {
+	union {
+		u_int8_t        b8[20];
+		u_int32_t       b32[5]; /* state (ABCDE) */
+	} h;
+	union {
+		u_int8_t        b8[8];
+		u_int32_t       b32[2];
+		u_int64_t       b64[1]; /* # of bits, modulo 2^64 (msb first) */
+	} c;
+	union {
+		u_int8_t        b8[64];
+		u_int32_t       b32[16]; /* input buffer */
+	} m;
+	u_int8_t        count;          /* unused; for compatibility only */
+} SHA1_CTX;
+
+/* For compatibility with the other SHA-1 implementation. */
+#define sha1_init(c)            SHA1Init(c)
+#define sha1_loop(c, b, l)      SHA1Update(c, b, l)
+#define sha1_result(c, b)       SHA1Final(b, c)
+
+extern void SHA1Init(SHA1_CTX *);
+extern void SHA1Update(SHA1_CTX *, const void *, size_t);
+extern void SHA1Final(void *, SHA1_CTX *);
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /*_CRYPTO_SHA1_H_*/
diff --git a/iokit/DriverKit/crypto/sha2.h b/iokit/DriverKit/crypto/sha2.h
new file mode 100644
index 00000000..2e93f35d
--- /dev/null
+++ b/iokit/DriverKit/crypto/sha2.h
@@ -0,0 +1,77 @@
+/*
+ * copyright (c) 2012 apple computer, inc. all rights reserved.
+ *
+ * @apple_osreference_license_header_start@
+ *
+ * this file contains original code and/or modifications of original code
+ * as defined in and that are subject to the apple public source license
+ * version 2.0 (the 'license'). you may not use this file except in
+ * compliance with the license. the rights granted to you under the license
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an apple operating system software license agreement.
+ *
+ * please obtain a copy of the license at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * the original code and all software distributed under the license are
+ * distributed on an 'as is' basis, without warranty of any kind, either
+ * express or implied, and apple hereby disclaims all such warranties,
+ * including without limitation, any warranties of merchantability,
+ * fitness for a particular purpose, quiet enjoyment or non-infringement.
+ * please see the license for the specific language governing rights and
+ * limitations under the license.
+ *
+ * @apple_osreference_license_header_end@
+ */
+
+#ifndef _CRYPTO_SHA2_H__
+#define _CRYPTO_SHA2_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <corecrypto/ccsha2.h>
+
+/*** SHA-256/384/512 Various Length Definitions ***********************/
+#define SHA256_BLOCK_LENGTH             CCSHA256_BLOCK_SIZE
+#define SHA256_DIGEST_LENGTH    CCSHA256_OUTPUT_SIZE
+#define SHA256_DIGEST_STRING_LENGTH     (SHA256_DIGEST_LENGTH * 2 + 1)
+#define SHA384_BLOCK_LENGTH             CCSHA512_BLOCK_SIZE
+#define SHA384_DIGEST_LENGTH    CCSHA384_OUTPUT_SIZE
+#define SHA384_DIGEST_STRING_LENGTH     (SHA384_DIGEST_LENGTH * 2 + 1)
+#define SHA512_BLOCK_LENGTH             CCSHA512_BLOCK_SIZE
+#define SHA512_DIGEST_LENGTH    CCSHA512_OUTPUT_SIZE
+#define SHA512_DIGEST_STRING_LENGTH     (SHA512_DIGEST_LENGTH * 2 + 1)
+
+typedef struct {
+	ccdigest_ctx_decl(CCSHA256_STATE_SIZE, CCSHA256_BLOCK_SIZE, ctx);
+} SHA256_CTX;
+
+typedef struct SHA512_CTX {
+	ccdigest_ctx_decl(CCSHA512_STATE_SIZE, CCSHA512_BLOCK_SIZE, ctx);
+} SHA512_CTX;
+
+typedef SHA512_CTX SHA384_CTX;
+
+/*** SHA-256/384/512 Function Prototypes ******************************/
+
+void SHA256_Init(SHA256_CTX *ctx);
+void SHA256_Update(SHA256_CTX *ctx, const void *data, size_t len);
+void SHA256_Final(void *digest, SHA256_CTX *ctx);
+
+void SHA384_Init(SHA384_CTX *ctx);
+void SHA384_Update(SHA384_CTX *ctx, const void *data, size_t len);
+void SHA384_Final(void *digest, SHA384_CTX *ctx);
+
+void SHA512_Init(SHA512_CTX *ctx);
+void SHA512_Update(SHA512_CTX *ctx, const void *data, size_t len);
+void SHA512_Final(void *digest, SHA512_CTX *ctx);
+
+#ifdef  __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* _CRYPTO_SHA2_H__ */
diff --git a/iokit/DriverKit/macro_help.h b/iokit/DriverKit/macro_help.h
new file mode 100644
index 00000000..02fff060
--- /dev/null
+++ b/iokit/DriverKit/macro_help.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+/*
+ * @OSF_COPYRIGHT@
+ */
+/*
+ * Mach Operating System
+ * Copyright (c) 1991,1990,1989,1988 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ *
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ *
+ * Carnegie Mellon requests users of this software to return to
+ *
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ *
+ * any improvements or extensions that they make and grant Carnegie Mellon
+ * the rights to redistribute these changes.
+ */
+/*
+ */
+/*
+ *	File:	kern/macro_help.h
+ *
+ *	Provide help in making lint-free macro routines
+ *
+ */
+
+#ifndef _KERN_MACRO_HELP_H_
+#define _KERN_MACRO_HELP_H_
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#define         NEVER           false
+#define         ALWAYS          true
+#else
+
+#include <mach/boolean.h>
+
+#ifdef  lint
+boolean_t       NEVER;
+boolean_t       ALWAYS;
+#else   /* lint */
+#define         NEVER           FALSE
+#define         ALWAYS          TRUE
+#endif  /* lint */
+
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+
+
+#define         MACRO_BEGIN     do {
+#define         MACRO_END       } while (NEVER)
+
+#define         MACRO_RETURN    if (ALWAYS) return
+
+#endif  /* _KERN_MACRO_HELP_H_ */
diff --git a/iokit/DriverKit/queue_implementation.h b/iokit/DriverKit/queue_implementation.h
new file mode 100644
index 00000000..32af20ba
--- /dev/null
+++ b/iokit/DriverKit/queue_implementation.h
@@ -0,0 +1,986 @@
+/*
+ * Copyright (c) 2000-2009 Apple Inc. All rights reserved.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+ *
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. The rights granted to you under the License
+ * may not be used to create, or enable the creation or redistribution of,
+ * unlawful or unlicensed copies of an Apple operating system, or to
+ * circumvent, violate, or enable the circumvention or violation of, any
+ * terms of an Apple operating system software license agreement.
+ *
+ * Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this file.
+ *
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ *
+ * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+ */
+/*
+ * @OSF_COPYRIGHT@
+ */
+/*
+ * Mach Operating System
+ * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University
+ * All Rights Reserved.
+ *
+ * Permission to use, copy, modify and distribute this software and its
+ * documentation is hereby granted, provided that both the copyright
+ * notice and this permission notice appear in all copies of the
+ * software, derivative works or modified versions, and any portions
+ * thereof, and that both notices appear in supporting documentation.
+ *
+ * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
+ * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
+ *
+ * Carnegie Mellon requests users of this software to return to
+ *
+ *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
+ *  School of Computer Science
+ *  Carnegie Mellon University
+ *  Pittsburgh PA 15213-3890
+ *
+ * any improvements or extensions that they make and grant Carnegie Mellon rights
+ * to redistribute these changes.
+ */
+/*
+ */
+/*
+ *	File:	queue.h
+ *	Author:	Avadis Tevanian, Jr.
+ *	Date:	1985
+ *
+ *	Type definitions for generic queues.
+ *
+ */
+
+#ifndef _KERN_QUEUE_H_
+#define _KERN_QUEUE_H_
+
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/macro_help.h>
+#else
+#include <mach/mach_types.h>
+#include <kern/macro_help.h>
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+
+#include <sys/cdefs.h>
+#include <string.h>
+
+__BEGIN_DECLS
+
+/*
+ * Queue Management APIs
+ *
+ * There are currently two subtly different methods of maintaining
+ * a queue of objects. Both APIs are contained in this file, and
+ * unfortunately overlap.
+ * (there is also a third way maintained in bsd/sys/queue.h)
+ *
+ * Both methods use a common queue head and linkage pattern:
+ *      The head of a queue is declared as:
+ *              queue_head_t q_head;
+ *
+ *      Elements in this queue are chained together using
+ *      struct queue_entry objects embedded within a structure:
+ *              struct some_data {
+ *                      int field1;
+ *                      int field2;
+ *                      ...
+ *                      queue_chain_t link;
+ *                      ...
+ *                      int last_field;
+ *              };
+ *      struct some_data is referred to as the queue "element."
+ *      (note that queue_chain_t is typedef'd to struct queue_entry)
+ *
+ * IMPORTANT: The two queue iteration methods described below are not
+ *            compatible with one another. You must choose one and be careful
+ *            to use only the supported APIs for that method.
+ *
+ * Method 1: chaining of queue_chain_t (linkage chains)
+ *      This method uses the next and prev pointers of the struct queue_entry
+ *      linkage object embedded in a queue element to point to the next or
+ *      previous queue_entry structure in the chain. The head of the queue
+ *      (the queue_head_t object) will point to the first and last
+ *      struct queue_entry object, and both the next and prev pointer will
+ *      point back to the head if the queue is empty.
+ *
+ *      This method is the most flexible method of chaining objects together
+ *      as it allows multiple chains through a given object, by embedding
+ *      multiple queue_chain_t objects in the structure, while simultaneously
+ *      providing fast removal and insertion into the queue using only
+ *      struct queue_entry object pointers.
+ *
+ *      ++ Valid APIs for this style queue ++
+ *      -------------------------------------
+ *              [C] queue_init
+ *              [C] queue_first
+ *              [C] queue_next
+ *              [C] queue_last
+ *              [C] queue_prev
+ *              [C] queue_end
+ *              [C] queue_empty
+ *
+ *              [1] enqueue
+ *              [1] dequeue
+ *              [1] enqueue_head
+ *              [1] enqueue_tail
+ *              [1] dequeue_head
+ *              [1] dequeue_tail
+ *              [1] remqueue
+ *              [1] insque
+ *              [1] remque
+ *              [1] re_queue_head
+ *              [1] re_queue_tail
+ *              [1] movqueue
+ *              [1] qe_element
+ *              [1] qe_foreach
+ *              [1] qe_foreach_safe
+ *              [1] qe_foreach_element
+ *              [1] qe_foreach_element_safe
+ *
+ * Method 2: chaining of elements (element chains)
+ *      This method uses the next and prev pointers of the struct queue_entry
+ *      linkage object embedded in a queue element to point to the next or
+ *      previous queue element (not another queue_entry). The head of the
+ *      queue will point to the first and last queue element (struct some_data
+ *      from the above example) NOT the embedded queue_entry structure. The
+ *      first queue element will have a prev pointer that points to the
+ *      queue_head_t, and the last queue element will have a next pointer
+ *      that points to the queue_head_t.
+ *
+ *      This method requires knowledge of the queue_head_t of the queue on
+ *      which an element resides in order to remove the element. Iterating
+ *      through the elements of the queue is also more cumbersome because
+ *      a check against the head pointer plus a cast then offset operation
+ *      must be performed at each step of the iteration.
+ *
+ *      ++ Valid APIs for this style queue ++
+ *      -------------------------------------
+ *              [C] queue_init
+ *              [C] queue_first
+ *              [C] queue_next
+ *              [C] queue_last
+ *              [C] queue_prev
+ *              [C] queue_end
+ *              [C] queue_empty
+ *
+ *              [2] queue_enter
+ *              [2] queue_enter_first
+ *              [2] queue_insert_before
+ *              [2] queue_insert_after
+ *              [2] queue_field
+ *              [2] queue_remove
+ *              [2] queue_remove_first
+ *              [2] queue_remove_last
+ *              [2] queue_assign
+ *              [2] queue_new_head
+ *              [2] queue_iterate
+ *
+ * Legend:
+ *      [C] -> API common to both methods
+ *      [1] -> API used only in method 1 (linkage chains)
+ *      [2] -> API used only in method 2 (element chains)
+ */
+
+/*
+ *	A generic doubly-linked list (queue).
+ */
+
+struct queue_entry {
+	struct queue_entry      *next;          /* next element */
+	struct queue_entry      *prev;          /* previous element */
+};
+
+typedef struct queue_entry      *queue_t;
+typedef struct queue_entry      queue_head_t;
+typedef struct queue_entry      queue_chain_t;
+typedef struct queue_entry      *queue_entry_t;
+
+#if defined(XNU_KERNEL_PRIVATE) || DRIVERKIT_FRAMEWORK_INCLUDE
+
+__abortlike
+extern void __queue_element_linkage_invalid(queue_entry_t e);
+
+static inline void
+__QUEUE_ELT_VALIDATE(queue_entry_t elt)
+{
+	if (elt->prev->next != elt || elt->next->prev != elt) {
+		__queue_element_linkage_invalid(elt);
+	}
+}
+
+static inline void
+__DEQUEUE_ELT_CLEANUP(queue_entry_t elt)
+{
+	elt->next = elt->prev = (queue_entry_t)NULL;
+}
+#else
+#define __QUEUE_ELT_VALIDATE(elt)       ((void)0)
+#define __DEQUEUE_ELT_CLEANUP(elt)      ((void)0)
+#endif /* !(XNU_KERNEL_PRIVATE || DRIVERKIT_FRAMEWORK_INCLUDE)*/
+
+/*
+ *	enqueue puts "elt" on the "queue".
+ *	dequeue returns the first element in the "queue".
+ *	remqueue removes the specified "elt" from its queue.
+ */
+
+#if !DRIVERKIT_FRAMEWORK_INCLUDE
+#define enqueue(queue, elt)     enqueue_tail(queue, elt)
+#define dequeue(queue)          dequeue_head(queue)
+#endif
+
+static __inline__ void
+enqueue_head(
+	queue_t         que,
+	queue_entry_t   elt)
+{
+	queue_entry_t   old_head;
+
+	__QUEUE_ELT_VALIDATE((queue_entry_t)que);
+	old_head = que->next;
+	elt->next = old_head;
+	elt->prev = que;
+	old_head->prev = elt;
+	que->next = elt;
+}
+
+static __inline__ void
+enqueue_tail(
+	queue_t         que,
+	queue_entry_t   elt)
+{
+	queue_entry_t   old_tail;
+
+	__QUEUE_ELT_VALIDATE((queue_entry_t)que);
+	old_tail = que->prev;
+	elt->next = que;
+	elt->prev = old_tail;
+	old_tail->next = elt;
+	que->prev = elt;
+}
+
+static __inline__ queue_entry_t
+dequeue_head(
+	queue_t que)
+{
+	queue_entry_t   elt = (queue_entry_t)NULL;
+	queue_entry_t   new_head;
+
+	if (que->next != que) {
+		elt = que->next;
+		__QUEUE_ELT_VALIDATE(elt);
+		new_head = elt->next; /* new_head may point to que if elt was the only element */
+		new_head->prev = que;
+		que->next = new_head;
+		__DEQUEUE_ELT_CLEANUP(elt);
+	}
+
+	return elt;
+}
+
+static __inline__ queue_entry_t
+dequeue_tail(
+	queue_t que)
+{
+	queue_entry_t   elt = (queue_entry_t)NULL;
+	queue_entry_t   new_tail;
+
+	if (que->prev != que) {
+		elt = que->prev;
+		__QUEUE_ELT_VALIDATE(elt);
+		new_tail = elt->prev; /* new_tail may point to queue if elt was the only element */
+		new_tail->next = que;
+		que->prev = new_tail;
+		__DEQUEUE_ELT_CLEANUP(elt);
+	}
+
+	return elt;
+}
+
+static __inline__ void
+remqueue(
+	queue_entry_t   elt)
+{
+	queue_entry_t   next_elt, prev_elt;
+
+	__QUEUE_ELT_VALIDATE(elt);
+	next_elt = elt->next;
+	prev_elt = elt->prev; /* next_elt may equal prev_elt (and the queue head) if elt was the only element */
+	next_elt->prev = prev_elt;
+	prev_elt->next = next_elt;
+	__DEQUEUE_ELT_CLEANUP(elt);
+}
+
+static __inline__ void
+insque(
+	queue_entry_t   entry,
+	queue_entry_t   pred)
+{
+	queue_entry_t   successor;
+
+	__QUEUE_ELT_VALIDATE(pred);
+	successor = pred->next;
+	entry->next = successor;
+	entry->prev = pred;
+	successor->prev = entry;
+	pred->next = entry;
+}
+
+static __inline__ void
+remque(
+	queue_entry_t elt)
+{
+	remqueue(elt);
+}
+
+/*
+ *	Function:	re_queue_head
+ *	Parameters:
+ *		queue_t que       : queue onto which elt will be pre-pended
+ *		queue_entry_t elt : element to re-queue
+ *	Description:
+ *		Remove elt from its current queue and put it onto the
+ *		head of a new queue
+ *	Note:
+ *		This should only be used with Method 1 queue iteration (linkage chains)
+ */
+static __inline__ void
+re_queue_head(queue_t que, queue_entry_t elt)
+{
+	queue_entry_t   n_elt, p_elt;
+
+	__QUEUE_ELT_VALIDATE(elt);
+	__QUEUE_ELT_VALIDATE((queue_entry_t)que);
+
+	/* remqueue */
+	n_elt = elt->next;
+	p_elt = elt->prev; /* next_elt may equal prev_elt (and the queue head) if elt was the only element */
+	n_elt->prev = p_elt;
+	p_elt->next = n_elt;
+
+	/* enqueue_head */
+	n_elt = que->next;
+	elt->next = n_elt;
+	elt->prev = que;
+	n_elt->prev = elt;
+	que->next = elt;
+}
+
+/*
+ *	Function:	re_queue_tail
+ *	Parameters:
+ *		queue_t que       : queue onto which elt will be appended
+ *		queue_entry_t elt : element to re-queue
+ *	Description:
+ *		Remove elt from its current queue and put it onto the
+ *		end of a new queue
+ *	Note:
+ *		This should only be used with Method 1 queue iteration (linkage chains)
+ */
+static __inline__ void
+re_queue_tail(queue_t que, queue_entry_t elt)
+{
+	queue_entry_t   n_elt, p_elt;
+
+	__QUEUE_ELT_VALIDATE(elt);
+	__QUEUE_ELT_VALIDATE((queue_entry_t)que);
+
+	/* remqueue */
+	n_elt = elt->next;
+	p_elt = elt->prev; /* next_elt may equal prev_elt (and the queue head) if elt was the only element */
+	n_elt->prev = p_elt;
+	p_elt->next = n_elt;
+
+	/* enqueue_tail */
+	p_elt = que->prev;
+	elt->next = que;
+	elt->prev = p_elt;
+	p_elt->next = elt;
+	que->prev = elt;
+}
+
+/*
+ *	Macro:		qe_element
+ *	Function:
+ *		Convert a queue_entry_t to a queue element pointer.
+ *		Get a pointer to the user-defined element containing
+ *		a given queue_entry_t
+ *	Header:
+ *		<type> * qe_element(queue_entry_t qe, <type>, field)
+ *			qe      - queue entry to convert
+ *			<type>  - what's in the queue (e.g., struct some_data)
+ *			<field> - is the chain field in <type>
+ *	Note:
+ *		Do not use pointer types for <type>
+ */
+#define qe_element(qe, type, field) __container_of(qe, type, field)
+
+/*
+ *	Macro:		qe_foreach
+ *	Function:
+ *		Iterate over each queue_entry_t structure.
+ *		Generates a 'for' loop, setting 'qe' to
+ *		each queue_entry_t in the queue.
+ *	Header:
+ *		qe_foreach(queue_entry_t qe, queue_t head)
+ *			qe   - iteration variable
+ *			head - pointer to queue_head_t (head of queue)
+ *	Note:
+ *		This should only be used with Method 1 queue iteration (linkage chains)
+ */
+#define qe_foreach(qe, head) \
+	for (qe = (head)->next; qe != (head); qe = (qe)->next)
+
+/*
+ *	Macro:		qe_foreach_safe
+ *	Function:
+ *		Safely iterate over each queue_entry_t structure.
+ *
+ *		Use this iterator macro if you plan to remove the
+ *		queue_entry_t, qe, from the queue during the
+ *		iteration.
+ *	Header:
+ *		qe_foreach_safe(queue_entry_t qe, queue_t head)
+ *			qe   - iteration variable
+ *			head - pointer to queue_head_t (head of queue)
+ *	Note:
+ *		This should only be used with Method 1 queue iteration (linkage chains)
+ */
+#define qe_foreach_safe(qe, head) \
+	for (queue_entry_t _ne = ((head)->next)->next, \
+	         __ ## qe ## _unused_shadow __unused = (qe = (head)->next); \
+	     qe != (head); \
+	     qe = _ne, _ne = (qe)->next)
+
+/*
+ *	Macro:		qe_foreach_element
+ *	Function:
+ *		Iterate over each _element_ in a queue
+ *		where each queue_entry_t points to another
+ *		queue_entry_t, i.e., managed by the [de|en]queue_head/
+ *		[de|en]queue_tail / remqueue / etc. function.
+ *	Header:
+ *		qe_foreach_element(<type> *elt, queue_t head, <field>)
+ *			elt     - iteration variable
+ *			<type>  - what's in the queue (e.g., struct some_data)
+ *			<field> - is the chain field in <type>
+ *	Note:
+ *		This should only be used with Method 1 queue iteration (linkage chains)
+ */
+#define qe_foreach_element(elt, head, field) \
+	for (elt = qe_element((head)->next, typeof(*(elt)), field); \
+	     &((elt)->field) != (head); \
+	     elt = qe_element((elt)->field.next, typeof(*(elt)), field))
+
+/*
+ *	Macro:		qe_foreach_element_safe
+ *	Function:
+ *		Safely iterate over each _element_ in a queue
+ *		where each queue_entry_t points to another
+ *		queue_entry_t, i.e., managed by the [de|en]queue_head/
+ *		[de|en]queue_tail / remqueue / etc. function.
+ *
+ *		Use this iterator macro if you plan to remove the
+ *		element, elt, from the queue during the iteration.
+ *	Header:
+ *		qe_foreach_element_safe(<type> *elt, queue_t head, <field>)
+ *			elt     - iteration variable
+ *			<type>  - what's in the queue (e.g., struct some_data)
+ *			<field> - is the chain field in <type>
+ *	Note:
+ *		This should only be used with Method 1 queue iteration (linkage chains)
+ */
+#define qe_foreach_element_safe(elt, head, field) \
+	for (typeof(*(elt)) *_nelt = qe_element(((head)->next)->next, typeof(*(elt)), field), \
+	     *__ ## elt ## _unused_shadow __unused = \
+	         (elt = qe_element((head)->next, typeof(*(elt)), field)); \
+	     &((elt)->field) != (head); \
+	     elt = _nelt, _nelt = qe_element((elt)->field.next, typeof(*(elt)), field)) \
+
+
+/*
+ *	Macro:		QUEUE_HEAD_INITIALIZER()
+ *	Function:
+ *		Static queue head initializer
+ */
+#define QUEUE_HEAD_INITIALIZER(name) \
+	{ &name, &name }
+
+/*
+ *	Macro:		queue_init
+ *	Function:
+ *		Initialize the given queue.
+ *	Header:
+ *		void queue_init(q)
+ *			queue_t		q;	\* MODIFIED *\
+ */
+#define queue_init(q)   \
+MACRO_BEGIN             \
+	(q)->next = (q);\
+	(q)->prev = (q);\
+MACRO_END
+
+/*
+ *	Macro:		queue_head_init
+ *	Function:
+ *		Initialize the given queue head
+ *	Header:
+ *		void queue_head_init(q)
+ *			queue_head_t	q;	\* MODIFIED *\
+ */
+#define queue_head_init(q) \
+	queue_init(&(q))
+
+/*
+ *	Macro:		queue_chain_init
+ *	Function:
+ *		Initialize the given queue chain element
+ *	Header:
+ *		void queue_chain_init(q)
+ *			queue_chain_t	q;	\* MODIFIED *\
+ */
+#define queue_chain_init(q) \
+	queue_init(&(q))
+
+/*
+ *	Macro:		queue_first
+ *	Function:
+ *		Returns the first entry in the queue,
+ *	Header:
+ *		queue_entry_t queue_first(q)
+ *			queue_t	q;		\* IN *\
+ */
+#define queue_first(q)  ((q)->next)
+
+/*
+ *	Macro:		queue_next
+ *	Function:
+ *		Returns the entry after an item in the queue.
+ *	Header:
+ *		queue_entry_t queue_next(qc)
+ *			queue_t qc;
+ */
+#define queue_next(qc)  ((qc)->next)
+
+/*
+ *	Macro:		queue_last
+ *	Function:
+ *		Returns the last entry in the queue.
+ *	Header:
+ *		queue_entry_t queue_last(q)
+ *			queue_t	q;		\* IN *\
+ */
+#define queue_last(q)   ((q)->prev)
+
+/*
+ *	Macro:		queue_prev
+ *	Function:
+ *		Returns the entry before an item in the queue.
+ *	Header:
+ *		queue_entry_t queue_prev(qc)
+ *			queue_t qc;
+ */
+#define queue_prev(qc)  ((qc)->prev)
+
+/*
+ *	Macro:		queue_end
+ *	Function:
+ *		Tests whether a new entry is really the end of
+ *		the queue.
+ *	Header:
+ *		boolean_t queue_end(q, qe)
+ *			queue_t q;
+ *			queue_entry_t qe;
+ */
+#define queue_end(q, qe)        ((q) == (qe))
+
+/*
+ *	Macro:		queue_empty
+ *	Function:
+ *		Tests whether a queue is empty.
+ *	Header:
+ *		boolean_t queue_empty(q)
+ *			queue_t q;
+ */
+#define queue_empty(q)          queue_end((q), queue_first(q))
+
+/*
+ *	Function:	movqueue
+ *	Parameters:
+ *		queue_t _old : head of a queue whose items will be moved
+ *		queue_t _new : new queue head onto which items will be moved
+ *	Description:
+ *		Rebase queue items in _old onto _new then re-initialize
+ *		the _old object to an empty queue.
+ *		Equivalent to the queue_new_head Method 2 macro
+ *	Note:
+ *		Similar to the queue_new_head macro, this macros is intented
+ *		to function as an initializer method for '_new' and thus may
+ *		leak any list items that happen to be on the '_new' list.
+ *		This should only be used with Method 1 queue iteration (linkage chains)
+ */
+static __inline__ void
+movqueue(queue_t _old, queue_t _new)
+{
+	queue_entry_t   next_elt, prev_elt;
+
+	__QUEUE_ELT_VALIDATE((queue_entry_t)_old);
+
+	if (queue_empty(_old)) {
+		queue_init(_new);
+		return;
+	}
+
+	/*
+	 * move the queue at _old to _new
+	 * and re-initialize _old
+	 */
+	next_elt = _old->next;
+	prev_elt = _old->prev;
+
+	_new->next = next_elt;
+	_new->prev = prev_elt;
+	next_elt->prev = _new;
+	prev_elt->next = _new;
+
+	queue_init(_old);
+}
+
+/*----------------------------------------------------------------*/
+/*
+ * Macros that operate on generic structures.  The queue
+ * chain may be at any location within the structure, and there
+ * may be more than one chain.
+ */
+
+/*
+ *	Macro:		queue_enter
+ *	Function:
+ *		Insert a new element at the tail of the queue.
+ *	Header:
+ *		void queue_enter(q, elt, type, field)
+ *			queue_t q;
+ *			<type> elt;
+ *			<type> is what's in our queue
+ *			<field> is the chain field in (*<type>)
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ *
+ *		We insert a compiler barrier after setting the fields in the element
+ *		to ensure that the element is updated before being added to the queue,
+ *		which is especially important because stackshot, which operates from
+ *		debugger context, iterates several queues that use this macro (the tasks
+ *		lists and threads lists) without locks. Without this barrier, the
+ *		compiler may re-order the instructions for this macro in a way that
+ *		could cause stackshot to trip over an inconsistent queue during
+ *		iteration.
+ */
+#define queue_enter(head, elt, type, field)                     \
+MACRO_BEGIN                                                     \
+	queue_entry_t __prev;                                   \
+                                                                \
+	__prev = (head)->prev;                                  \
+	(elt)->field.prev = __prev;                             \
+	(elt)->field.next = head;                               \
+	__compiler_barrier();                                   \
+	if ((head) == __prev) {                                 \
+	        (head)->next = (queue_entry_t) (elt);           \
+	}                                                       \
+	else {                                                  \
+	        ((type)(void *)__prev)->field.next =            \
+	                (queue_entry_t)(elt);                   \
+	}                                                       \
+	(head)->prev = (queue_entry_t) elt;                     \
+MACRO_END
+
+/*
+ *	Macro:		queue_enter_first
+ *	Function:
+ *		Insert a new element at the head of the queue.
+ *	Header:
+ *		void queue_enter_first(q, elt, type, field)
+ *			queue_t q;
+ *			<type> elt;
+ *			<type> is what's in our queue
+ *			<field> is the chain field in (*<type>)
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_enter_first(head, elt, type, field)               \
+MACRO_BEGIN                                                     \
+	queue_entry_t __next;                                   \
+                                                                \
+	__next = (head)->next;                                  \
+	if ((head) == __next) {                                 \
+	        (head)->prev = (queue_entry_t) (elt);           \
+	}                                                       \
+	else {                                                  \
+	        ((type)(void *)__next)->field.prev =            \
+	                (queue_entry_t)(elt);                   \
+	}                                                       \
+	(elt)->field.next = __next;                             \
+	(elt)->field.prev = head;                               \
+	(head)->next = (queue_entry_t) elt;                     \
+MACRO_END
+
+/*
+ *	Macro:		queue_insert_before
+ *	Function:
+ *		Insert a new element before a given element.
+ *	Header:
+ *		void queue_insert_before(q, elt, cur, type, field)
+ *			queue_t q;
+ *			<type> elt;
+ *			<type> cur;
+ *			<type> is what's in our queue
+ *			<field> is the chain field in (*<type>)
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_insert_before(head, elt, cur, type, field)                \
+MACRO_BEGIN                                                             \
+	queue_entry_t __prev;                                           \
+                                                                        \
+	if ((head) == (queue_entry_t)(cur)) {                           \
+	        (elt)->field.next = (head);                             \
+	        if ((head)->next == (head)) {   /* only element */      \
+	                (elt)->field.prev = (head);                     \
+	                (head)->next = (queue_entry_t)(elt);            \
+	        } else {                        /* last element */      \
+	                __prev = (elt)->field.prev = (head)->prev;      \
+	                ((type)(void *)__prev)->field.next =            \
+	                        (queue_entry_t)(elt);                   \
+	        }                                                       \
+	        (head)->prev = (queue_entry_t)(elt);                    \
+	} else {                                                        \
+	        (elt)->field.next = (queue_entry_t)(cur);               \
+	        if ((head)->next == (queue_entry_t)(cur)) {             \
+	/* first element */     \
+	                (elt)->field.prev = (head);                     \
+	                (head)->next = (queue_entry_t)(elt);            \
+	        } else {                        /* middle element */    \
+	                __prev = (elt)->field.prev = (cur)->field.prev; \
+	                ((type)(void *)__prev)->field.next =            \
+	                        (queue_entry_t)(elt);                   \
+	        }                                                       \
+	        (cur)->field.prev = (queue_entry_t)(elt);               \
+	}                                                               \
+MACRO_END
+
+/*
+ *	Macro:		queue_insert_after
+ *	Function:
+ *		Insert a new element after a given element.
+ *	Header:
+ *		void queue_insert_after(q, elt, cur, type, field)
+ *			queue_t q;
+ *			<type> elt;
+ *			<type> cur;
+ *			<type> is what's in our queue
+ *			<field> is the chain field in (*<type>)
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_insert_after(head, elt, cur, type, field)                 \
+MACRO_BEGIN                                                             \
+	queue_entry_t __next;                                           \
+                                                                        \
+	if ((head) == (queue_entry_t)(cur)) {                           \
+	        (elt)->field.prev = (head);                             \
+	        if ((head)->next == (head)) {   /* only element */      \
+	                (elt)->field.next = (head);                     \
+	                (head)->prev = (queue_entry_t)(elt);            \
+	        } else {                        /* first element */     \
+	                __next = (elt)->field.next = (head)->next;      \
+	                ((type)(void *)__next)->field.prev =            \
+	                        (queue_entry_t)(elt);                   \
+	        }                                                       \
+	        (head)->next = (queue_entry_t)(elt);                    \
+	} else {                                                        \
+	        (elt)->field.prev = (queue_entry_t)(cur);               \
+	        if ((head)->prev == (queue_entry_t)(cur)) {             \
+	/* last element */      \
+	                (elt)->field.next = (head);                     \
+	                (head)->prev = (queue_entry_t)(elt);            \
+	        } else {                        /* middle element */    \
+	                __next = (elt)->field.next = (cur)->field.next; \
+	                ((type)(void *)__next)->field.prev =            \
+	                        (queue_entry_t)(elt);                   \
+	        }                                                       \
+	        (cur)->field.next = (queue_entry_t)(elt);               \
+	}                                                               \
+MACRO_END
+
+/*
+ *	Macro:		queue_field [internal use only]
+ *	Function:
+ *		Find the queue_chain_t (or queue_t) for the
+ *		given element (thing) in the given queue (head)
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_field(head, thing, type, field)                   \
+	        (((head) == (thing)) ? (head) : &((type)(void *)(thing))->field)
+
+/*
+ *	Macro:		queue_remove
+ *	Function:
+ *		Remove an arbitrary item from the queue.
+ *	Header:
+ *		void queue_remove(q, qe, type, field)
+ *			arguments as in queue_enter
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_remove(head, elt, type, field)                    \
+MACRO_BEGIN                                                     \
+	queue_entry_t	__next, __prev;                         \
+                                                                \
+	__next = (elt)->field.next;                             \
+	__prev = (elt)->field.prev;                             \
+                                                                \
+	if ((head) == __next)                                   \
+	        (head)->prev = __prev;                          \
+	else                                                    \
+	        ((type)(void *)__next)->field.prev = __prev;    \
+                                                                \
+	if ((head) == __prev)                                   \
+	        (head)->next = __next;                          \
+	else                                                    \
+	        ((type)(void *)__prev)->field.next = __next;    \
+                                                                \
+	(elt)->field.next = NULL;                               \
+	(elt)->field.prev = NULL;                               \
+MACRO_END
+
+/*
+ *	Macro:		queue_remove_first
+ *	Function:
+ *		Remove and return the entry at the head of
+ *		the queue.
+ *	Header:
+ *		queue_remove_first(head, entry, type, field)
+ *		entry is returned by reference
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_remove_first(head, entry, type, field)            \
+MACRO_BEGIN                                                     \
+	queue_entry_t	__next;                                 \
+                                                                \
+	(entry) = (type)(void *) ((head)->next);                \
+	__next = (entry)->field.next;                           \
+                                                                \
+	if ((head) == __next)                                   \
+	        (head)->prev = (head);                          \
+	else                                                    \
+	        ((type)(void *)(__next))->field.prev = (head);  \
+	(head)->next = __next;                                  \
+                                                                \
+	(entry)->field.next = NULL;                             \
+	(entry)->field.prev = NULL;                             \
+MACRO_END
+
+/*
+ *	Macro:		queue_remove_last
+ *	Function:
+ *		Remove and return the entry at the tail of
+ *		the queue.
+ *	Header:
+ *		queue_remove_last(head, entry, type, field)
+ *		entry is returned by reference
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_remove_last(head, entry, type, field)             \
+MACRO_BEGIN                                                     \
+	queue_entry_t	__prev;                                 \
+                                                                \
+	(entry) = (type)(void *) ((head)->prev);                \
+	__prev = (entry)->field.prev;                           \
+                                                                \
+	if ((head) == __prev)                                   \
+	        (head)->next = (head);                          \
+	else                                                    \
+	        ((type)(void *)(__prev))->field.next = (head);  \
+	(head)->prev = __prev;                                  \
+                                                                \
+	(entry)->field.next = NULL;                             \
+	(entry)->field.prev = NULL;                             \
+MACRO_END
+
+/*
+ *	Macro:		queue_assign
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_assign(to, from, type, field)                     \
+MACRO_BEGIN                                                     \
+	((type)(void *)((from)->prev))->field.next = (to);      \
+	((type)(void *)((from)->next))->field.prev = (to);      \
+	*to = *from;                                            \
+MACRO_END
+
+/*
+ *	Macro:		queue_new_head
+ *	Function:
+ *		rebase old queue to new queue head
+ *	Header:
+ *		queue_new_head(old, new, type, field)
+ *			queue_t old;
+ *			queue_t new;
+ *			<type> is what's in our queue
+ *                      <field> is the chain field in (*<type>)
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_new_head(old, new, type, field)                   \
+MACRO_BEGIN                                                     \
+	if (!queue_empty(old)) {                                \
+	        *(new) = *(old);                                \
+	        ((type)(void *)((new)->next))->field.prev =     \
+	                (new);                                  \
+	        ((type)(void *)((new)->prev))->field.next =     \
+	                (new);                                  \
+	} else {                                                \
+	        queue_init(new);                                \
+	}                                                       \
+MACRO_END
+
+/*
+ *	Macro:		queue_iterate
+ *	Function:
+ *		iterate over each item in the queue.
+ *		Generates a 'for' loop, setting elt to
+ *		each item in turn (by reference).
+ *	Header:
+ *		queue_iterate(q, elt, type, field)
+ *			queue_t q;
+ *			<type> elt;
+ *			<type> is what's in our queue
+ *			<field> is the chain field in (*<type>)
+ *	Note:
+ *		This should only be used with Method 2 queue iteration (element chains)
+ */
+#define queue_iterate(head, elt, type, field)                   \
+	for ((elt) = (type)(void *) queue_first(head);          \
+	     !queue_end((head), (queue_entry_t)(elt));          \
+	     (elt) = (type)(void *) queue_next(&(elt)->field))
+
+
+__END_DECLS
+
+#endif  /* _KERN_QUEUE_H_ */
diff --git a/iokit/DriverKit/safe_allocation.h b/iokit/DriverKit/safe_allocation.h
new file mode 100644
index 00000000..1d4759b1
--- /dev/null
+++ b/iokit/DriverKit/safe_allocation.h
@@ -0,0 +1,490 @@
+//
+// Copyright (c) 2019-2021 Apple, Inc. All rights reserved.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
+//
+// This file contains Original Code and/or Modifications of Original Code
+// as defined in and that are subject to the Apple Public Source License
+// Version 2.0 (the 'License'). You may not use this file except in
+// compliance with the License. The rights granted to you under the License
+// may not be used to create, or enable the creation or redistribution of,
+// unlawful or unlicensed copies of an Apple operating system, or to
+// circumvent, violate, or enable the circumvention or violation of, any
+// terms of an Apple operating system software license agreement.
+//
+// Please obtain a copy of the License at
+// http://www.opensource.apple.com/apsl/ and read it before using this file.
+//
+// The Original Code and all software distributed under the License are
+// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+// Please see the License for the specific language governing rights and
+// limitations under the License.
+//
+// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
+//
+
+#ifndef XNU_LIBKERN_LIBKERN_CXX_SAFE_ALLOCATION_H
+#define XNU_LIBKERN_LIBKERN_CXX_SAFE_ALLOCATION_H
+
+#if !TAPI
+
+#include <stddef.h>
+#include <stdint.h>
+#include <os/base.h>
+#if DRIVERKIT_FRAMEWORK_INCLUDE
+#include <DriverKit/bounded_ptr.h>
+#else
+#include <libkern/c++/bounded_ptr.h>
+#endif /* DRIVERKIT_FRAMEWORK_INCLUDE */
+
+#if (defined(__has_include) && __has_include(<__xnu_libcxx_sentinel.h>) && __has_include(<new>))
+#include <new>
+#else
+void* operator new(size_t, void*) noexcept; // forward declaration needed for placement-new
+#endif
+
+namespace libkern {
+namespace sa_detail {
+// TODO: Deduplicate these utilities with other smart pointer utilities
+using nullptr_t = decltype(nullptr);
+template <typename T>
+constexpr bool is_trivially_destructible_v = __is_trivially_destructible(T);
+template <typename T>
+constexpr bool is_empty_v = __is_empty(T);
+template <typename T>
+constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(T);
+
+template <bool Cond, typename T = void> struct enable_if;
+template <typename T> struct enable_if<true, T> { using type = T; };
+template <bool Cond, typename T = void> using enable_if_t = typename enable_if<Cond, T>::type;
+
+template <typename T> struct remove_const { using type = T; };
+template <typename T> struct remove_const<T const> { using type = T; };
+template <typename T> using remove_const_t = typename remove_const<T>::type;
+
+template <typename T>
+void
+generic_swap(T& a, T& b)
+{
+	T tmp = a;
+	a = b;
+	b = tmp;
+}
+
+template <typename T, enable_if_t<!is_trivially_destructible_v<T> >* = nullptr>
+void
+destroy(T* first, T* last)
+{
+	for (; first != last; ++first) {
+		first->~T();
+	}
+}
+
+template <typename T, enable_if_t<is_trivially_destructible_v<T> >* = nullptr>
+void
+destroy(T*, T*)
+{
+	// Nothing to do, the elements are trivially destructible
+}
+
+template <typename T>
+void
+uninitialized_value_construct(T* first, T* last)
+{
+	for (; first != last; ++first) {
+		::new (static_cast<void*>(first)) T();
+	}
+}
+} // end namespace sa_detail
+
+struct adopt_memory_t {
+	explicit constexpr
+	adopt_memory_t() = default;
+};
+inline constexpr adopt_memory_t adopt_memory{};
+
+struct allocate_memory_t {
+	explicit constexpr
+	allocate_memory_t() = default;
+};
+inline constexpr allocate_memory_t allocate_memory{};
+
+struct allocate_memory_zero_t {
+	explicit constexpr
+	allocate_memory_zero_t() = default;
+};
+inline constexpr allocate_memory_zero_t allocate_memory_zero{};
+
+// Lightweight utility class representing a dynamically allocated slab of
+// memory, with contiguous objects in it.
+//
+// The main purpose `safe_allocation` is to:
+// 1. Manage a uniquely-owned allocation of memory containing multiple objects
+// 2. Check that the allocation is accessed within its bounds on indexing operations
+// 3. Act as a source for obtaining (non-owning) `bounded_ptr`s to the underlying memory
+//
+// In fact, `safe_allocation` should be the primary source of `bounded_ptr`s to
+// heap-allocated memory, via its `.begin()` and `.end()` methods. `safe_allocation`
+// is optimized for use cases where simple scratch space is needed for calculation
+// and deallocated once the calculation is done. As such, it is not a full-blown
+// container class, which drives many design choices behind `safe_allocation`:
+//
+// 1. It can't be copied or compared for equality -- `safe_allocation` is not a proper value type
+// 2. It can't be resized -- this keeps the design extremely simple and free of overhead
+// 3. You can transfer ownership of `safe_allocation` by using std::move
+//
+// Design decision: stateless allocators
+// =====================================
+// Only allow stateless allocators. While we could technically handle stateful
+// allocators (as the C++ Standard Library) does, the benefit of doing so
+// compared to the added complexity is absolutely not worth it. Supporting
+// stateful allocators everywhere in C++ is regarded (at least in the
+// Standardization Committee) as one of the worst design mistakes we've made,
+// and so we won't repeat it here.
+//
+// Design decision: size() is 0 when allocation is null
+// ====================================================
+// When the `safe_allocation` is null (because it's been moved-from, or because
+// allocation failed, or whatever), we could technically leave the `size_`
+// undefined (as long as we make `data_` null). However, this would mean
+// that querying the size of the allocation in that case is undefined behavior
+// (UB), which is seen as something bad in the context of a type that vends
+// itself as safe. So instead, we "overimplement" the type to provide stronger
+// guarantees than would be strictly required if performance were the main goal.
+template <typename T, typename Allocator, typename TrappingPolicy>
+struct safe_allocation {
+	static_assert(sa_detail::is_empty_v<Allocator>,
+	    "safe_allocation<T, Alloc, ...> requires the Allocator to be stateless");
+
+	// Create a null allocation, pointing to no memory.
+	//
+	// A null allocation can be destroyed, assigned-to, checked for nullness,
+	// and otherwise queries for length, but trying to access an element of
+	// the allocation will fail.
+	//
+	// A null allocation basically behaves as an empty array, i.e. `begin()`
+	// and `end()` will return iterators that are equal and `size()` will
+	// return `0`.
+	explicit constexpr safe_allocation() noexcept : data_(nullptr), size_(0)
+	{
+	}
+
+	constexpr safe_allocation(sa_detail::nullptr_t) noexcept : safe_allocation()
+	{
+	}
+
+	// Create an allocation pointing to already-allocated and initialized memory.
+	//
+	// This constructor attaches existing memory to a `safe_allocation`, such
+	// that it will be released automatically when the `safe_allocation` goes
+	// out of scope. The objects in that memory must already have been
+	// initialized, or they must be initialized before the `safe_allocation`
+	// goes out of scope.
+	//
+	// The `n` argument is the number of objects of type `T` in the allocation,
+	// i.e. `n * sizeof(T)` bytes should have been allocated.
+	//
+	// Note that the memory MUST have been allocated with an allocator compatible
+	// with the `safe_allocation`'s `Allocator`, since the memory will be
+	// deallocated using that `Allocator`. Bad things will happen if, for
+	// example, `adopt_memory` is used with memory allocated on the stack:
+	// the destructor will try to deallocate that memory and will fail to do so.
+	explicit safe_allocation(T* data, size_t n, adopt_memory_t) : data_(data)
+	{
+		if (__improbable(n > UINT32_MAX)) {
+			TrappingPolicy::trap("safe_allocation size exceeds UINT32_MAX");
+		}
+
+		size_ = static_cast<uint32_t>(n);
+	}
+
+	// Allocate memory for `n` objects of type `T`, and manage it.
+	//
+	// This constructor allocates enough memory for `n` objects of type `T`
+	// using the `Allocator`, and manages that. Each object in the allocation
+	// is value-initialized (either set to 0 or the default-constructor called).
+	//
+	// If either `n * sizeof(T)` overflows or the allocation fails, the
+	// resulting `safe_allocation` will be null. It is therefore necessary
+	// to check whether the allocation is null after using this constructor.
+	explicit safe_allocation(size_t n, allocate_memory_t)
+	{
+		size_t bytes;
+		if (__improbable(os_mul_overflow(n, sizeof(T), &bytes) || (n > UINT32_MAX))) {
+			data_ = nullptr;
+			size_ = 0;
+		} else {
+			data_ = reinterpret_cast<T*>(Allocator::allocate(bytes));
+			size_ = static_cast<uint32_t>(n);
+			using RawT = sa_detail::remove_const_t<T>;
+			RawT* const data = const_cast<RawT*>(data_);
+			sa_detail::uninitialized_value_construct(data, data + size_);
+		}
+	}
+
+	// same as allocate_memory_t variant but allocated data is zero-initialized
+	explicit safe_allocation(size_t n, allocate_memory_zero_t)
+	{
+		static_assert(__is_scalar(T) || __is_aggregate(T),
+		    "Creating objects via zero-allocation requires those objects to be scalars or aggregates (more broadly implicit lifetime types)");
+		size_t bytes;
+		if (__improbable(os_mul_overflow(n, sizeof(T), &bytes) || (n > UINT32_MAX))) {
+			data_ = nullptr;
+			size_ = 0;
+		} else {
+			data_ = reinterpret_cast<T*>(Allocator::allocate_zero(bytes));
+			size_ = static_cast<uint32_t>(n);
+		}
+	}
+
+	// A `safe_allocation` can't be copied, because it is not a proper value
+	// type and it doesn't assume that the elements of the allocation can be
+	// copied.
+	safe_allocation(safe_allocation const&) = delete;
+	safe_allocation& operator=(safe_allocation const&) = delete;
+
+	// Moves the ownership of an allocation from one `safe_allocation` to
+	// another one.
+	//
+	// After this operation, the moved-from `safe_allocation` is null, and
+	// any iterator into the moved-from `safe_allocation` are now tied to
+	// the `safe_allocation` that's the target of the assignment, in the
+	// sense that the iterators will be invalidated when the target of the
+	// assignment goes out of scope, not when the moved-from allocation
+	// goes out of scope.
+	safe_allocation(safe_allocation&& other) noexcept : data_(other.data_), size_(other.size_)
+	{
+		other.data_ = nullptr;
+		other.size_ = 0;
+	}
+
+	// Clears a `safe_allocation`, making it a null allocation.
+	//
+	// If the `safe_allocation` was pointing to valid memory, the objects
+	// in that memory are destroyed and that memory is freed.
+	safe_allocation&
+	operator=(sa_detail::nullptr_t)
+	{
+		if (data_ != nullptr) {
+			destroy_dealloc_(data_, size_);
+		}
+		data_ = nullptr;
+		size_ = 0;
+		return *this;
+	}
+
+	// Moves the ownership of an allocation from one `safe_allocation` to
+	// another one.
+	//
+	// After this operation, the moved-from `safe_allocation` is null, and
+	// any iterator to the moved-from `safe_allocation` obtained before the
+	// move operation are invalidated.
+	//
+	// If the destination `safe_allocation` was pointing to memory before the
+	// move-assignment, the objects in that memory are destroyed and the
+	// memory itself is freed.
+	//
+	// In case of self-move-assignment, nothing is done.
+	safe_allocation&
+	operator=(safe_allocation&& other)
+	{
+		if (&other == this) {
+			return *this;
+		}
+
+		T* old_data = data_;
+		size_t old_size = size_;
+
+		data_ = other.data_;
+		size_ = other.size_;
+		other.data_ = nullptr;
+		other.size_ = 0;
+
+		if (old_data != nullptr) {
+			destroy_dealloc_(old_data, old_size);
+		}
+
+		return *this;
+	}
+
+	// Destroys a `safe_allocation`, destroying the objects in it and
+	// deallocating the underlying memory with the `Allocator`.
+	//
+	// If the `safe_allocation` is null, this destructor does nothing.
+	~safe_allocation()
+	{
+		if (data_ != nullptr) {
+			destroy_dealloc_(data_, size_);
+		}
+	}
+
+	// Returns whether a `safe_allocation` is non-null, i.e. whether it is
+	// pointing to some memory.
+	explicit
+	operator bool() const noexcept
+	{
+		return data_ != nullptr;
+	}
+
+	using iterator = bounded_ptr<T, TrappingPolicy>;
+	using const_iterator = bounded_ptr<T const, TrappingPolicy>;
+
+	// The following methods allow obtaining iterators (i.e. cursors) to
+	// objects inside a `safe_allocation`.
+	//
+	// The iterators of a `safe_allocation` are `bounded_ptr`s, which know
+	// the bounds of the allocation and will trap when dereferenced outside
+	// of those bounds.
+	//
+	// `begin()` returns a (const) iterator to the first element in the
+	// allocation, and `end()` returns a (const) iterator to one-past-the-last
+	// element in the allocation. The `end()` iterator can't be dereferenced,
+	// since it is out of bounds.
+	//
+	// If the allocation is null, these methods will return null `bounded_ptr`s,
+	// which can be checked for equality but can't be dereferenced.
+	OS_ALWAYS_INLINE iterator
+	begin() noexcept
+	{
+		if (data_ == nullptr) {
+			return iterator();
+		} else {
+			return iterator(data_, data_, data_ + size_);
+		}
+	}
+	OS_ALWAYS_INLINE const_iterator
+	begin() const noexcept
+	{
+		if (data_ == nullptr) {
+			return const_iterator();
+		} else {
+			return const_iterator(data_, data_, data_ + size_);
+		}
+	}
+	iterator
+	end() noexcept
+	{
+		if (data_ == nullptr) {
+			return iterator();
+		} else {
+			return iterator(data_ + size_, data_, data_ + size_);
+		}
+	}
+	const_iterator
+	end() const noexcept
+	{
+		if (data_ == nullptr) {
+			return const_iterator();
+		} else {
+			return const_iterator(data_ + size_, data_, data_ + size_);
+		}
+	}
+
+	// Returns the number of objects in the allocation.
+	//
+	// This method returns `0` if the allocation is null, since such an
+	// allocation behaves the same as an empty range.
+	size_t
+	size() const
+	{
+		return size_;
+	}
+
+	// Returns a non-owning pointer to the underlying memory managed by a
+	// `safe_allocation`.
+	//
+	// This method can be called even if the `safe_allocation` is null, in
+	// which case the returned pointer will be null.
+	T*
+	data() noexcept
+	{
+		return data_;
+	}
+	T const*
+	data() const noexcept
+	{
+		return data_;
+	}
+
+	// Access the n-th element of an allocation.
+	//
+	// If `n` is out of the bounds of the allocation, this operation will
+	// trap. If the allocation is null, this operation will trap too.
+	//
+	// Design note:
+	// We voluntarily use a signed type to represent the index even though a
+	// negative index will always cause a trap. If we used an unsigned type,
+	// we could get an implicit conversion from signed to unsigned, which
+	// could silently wrap around. We think trapping early is more likely
+	// to be helpful in this situation.
+	OS_ALWAYS_INLINE T&
+	operator[](ptrdiff_t n)
+	{
+		return begin()[n]; // trap happens in `bounded_ptr` if null or OOB
+	}
+	OS_ALWAYS_INLINE T const&
+	operator[](ptrdiff_t n) const
+	{
+		return begin()[n]; // trap happens in `bounded_ptr` if null or OOB
+	}
+
+private:
+	// Swap support
+	friend void
+	swap(safe_allocation& a, safe_allocation& b) noexcept
+	{
+		sa_detail::generic_swap(a.data_, b.data_);
+		sa_detail::generic_swap(a.size_, b.size_);
+	}
+
+	static void
+	destroy_dealloc_(T* ptr, size_t size)
+	{
+		sa_detail::destroy(ptr, ptr + size);
+		// `size * sizeof(T)` can't overflow, because it would have
+		// overflowed when the allocation was performed otherwise.
+		using RawT = sa_detail::remove_const_t<T>;
+		Allocator::deallocate(const_cast<RawT*>(ptr), size * sizeof(T));
+	}
+
+	T* data_;
+	uint32_t size_;
+};
+
+// The comparison functions against `nullptr` all return whether the allocation
+// is null or not.
+template <typename T, typename A, typename P>
+bool
+operator==(safe_allocation<T, A, P> const& x, sa_detail::nullptr_t)
+{
+	return !static_cast<bool>(x);
+}
+
+template <typename T, typename A, typename P>
+bool
+operator!=(safe_allocation<T, A, P> const& x, sa_detail::nullptr_t)
+{
+	return !(x == nullptr);
+}
+
+template <typename T, typename A, typename P>
+bool
+operator==(sa_detail::nullptr_t, safe_allocation<T, A, P> const& x)
+{
+	return x == nullptr;
+}
+
+template <typename T, typename A, typename P>
+bool
+operator!=(sa_detail::nullptr_t, safe_allocation<T, A, P> const& x)
+{
+	return !(x == nullptr);
+}
+} // end namespace libkern
+
+#endif /* !TAPI */
+
+#endif // !XNU_LIBKERN_LIBKERN_CXX_SAFE_ALLOCATION_H
diff --git a/iokit/IOKit/IORPC.h b/iokit/IOKit/IORPC.h
index 7ffc6b73..5d49f179 100644
--- a/iokit/IOKit/IORPC.h
+++ b/iokit/IOKit/IORPC.h
@@ -267,4 +267,6 @@ struct OSClassDescription {
 	char        metaMethodNames[0];
 };
 
+IORPCMessage *IORPCMessageFromMach(IORPCMessageMach * msg, bool reply);
+
 #endif /* _IORPC_H */
diff --git a/iokit/Kernel/IOUserServer.cpp b/iokit/Kernel/IOUserServer.cpp
index b14ca9c4..d1f8f096 100644
--- a/iokit/Kernel/IOUserServer.cpp
+++ b/iokit/Kernel/IOUserServer.cpp
@@ -2404,7 +2404,7 @@ OSMetaClassBase::Invoke(IORPC rpc)
 	IORPCMessage    * message;
 
 	assert(rpc.sendSize >= (sizeof(IORPCMessageMach) + sizeof(IORPCMessage)));
-	message = rpc.kernelContent;
+	message = IORPCMessageFromMach(rpc.message, false);
 	if (!message) {
 		return kIOReturnIPCError;
 	}
@@ -3629,6 +3629,45 @@ IORPCMessageFromMachReply(IORPCMessageMach * msg)
 	return (IORPCMessage *)(uintptr_t) desc;
 }
 
+IORPCMessage *
+IORPCMessageFromMach(IORPCMessageMach * msg, bool reply)
+{
+	mach_msg_size_t              idx, count;
+	mach_msg_port_descriptor_t * desc;
+	mach_msg_port_descriptor_t * maxDesc;
+	size_t                       size, msgsize;
+	bool                         upgrade;
+
+	msgsize = msg->msgh.msgh_size;
+	count   = msg->msgh_body.msgh_descriptor_count;
+	desc    = &msg->objects[0];
+	maxDesc = (typeof(maxDesc))(((uintptr_t) msg) + msgsize);
+	upgrade = (msg->msgh.msgh_id != (reply ? kIORPCVersionCurrentReply : kIORPCVersionCurrent));
+
+	if (upgrade) {
+		OSReportWithBacktrace("obsolete message");
+		return NULL;
+	}
+
+	for (idx = 0; idx < count; idx++) {
+		if (desc >= maxDesc) {
+			return NULL;
+		}
+		switch (desc->type) {
+		case MACH_MSG_PORT_DESCRIPTOR:
+			size = sizeof(mach_msg_port_descriptor_t);
+			break;
+		case MACH_MSG_OOL_DESCRIPTOR:
+			size = sizeof(mach_msg_ool_descriptor_t);
+			break;
+		default:
+			return NULL;
+		}
+		desc = (typeof(desc))(((uintptr_t) desc) + size);
+	}
+	return (IORPCMessage *)(uintptr_t) desc;
+}
+
 ipc_port_t
 IOUserServer::copySendRightForObject(OSObject * object, ipc_kobject_type_t type)
 {
